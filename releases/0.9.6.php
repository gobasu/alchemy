<?php
/**
 * Alchemy Framework (http://alchemyframework.org/)
 *
 * @link      http://github.com/dkraczkowski/alchemy for the canonical source repository
 * @copyright Copyright (c) 2012-2013 Dawid Kraczkowski
 * @license   https://raw.github.com/dkraczkowski/alchemy/master/LICENSE New BSD License
 * @version 0.9.6
 */

namespace alchemy\app {
    use alchemy\http\Router,alchemy\event\EventHub,alchemy\app\event\OnError,alchemy\app\event\OnShutdown,alchemy\http\Request,alchemy\http\Response,alchemy\storage\Session,alchemy\object\ILoadable,alchemy\event\EventDispatcher,alchemy\event\Event,alchemy\app\plugin\PluginLoader;
    class ApplicationException extends \Exception {}
    class ApplicationInvalidDirnameException extends ApplicationException {}
    class ApplicationResourceNotFoundException extends ApplicationException {}
    class Application {  public static function instance() { if (self::$instance instanceof Application) { return self::$instance; } $class = get_called_class(); return self::$instance = new $class; }  protected function __construct() { \alchemy\event\EventHub::initialize(); $this->router = new Router(); }  public function onURI($uri, $callback) { $this->router->addResource($uri, $callback); }  public function setApplicationDir($dir) { if (!is_dir($dir)) { throw new ApplicationInvalidDirnameException('Application dir does not exists'); } define('AL_APP_DIR', $dir); $cacheDir = AL_APP_DIR . '/cache'; if (!is_writable($cacheDir)) { $cacheDir = sys_get_temp_dir(); } define('AL_APP_CACHE_DIR', $cacheDir); Loader::register(function($className){ $path = Loader::getPathForApplicationClass($className); if (is_readable($path)) { require_once $path;  if (is_subclass_of($className, 'alchemy\storage\db\Model')) { $className::onLoad(); } } }); }  public function setPluginDir($dir) { $this->pluginDir = $dir; } public function getPluginDir($dir) { return $this->pluginDir; }  public function setConfigDir($name) {  if ($this->configLoader instanceof \alchemy\app\util\Config && $this->configLoader->isLoaded()) { return false; } $directory = AL_APP_DIR . '/' . $name; if (!is_dir($directory)) { throw new ApplicationInvalidDirnameException('Config dir `' . $directory . '` does not exist'); } $this->configLoader = new \alchemy\app\util\Config($directory); return true; } public function onError($callable) { $this->onErrorHandler = new Callback($callable); } public function onStartup($callable) { $this->onStartupHandler = new Callback($callable); }  public function getConfig() { if ($this->configLoader && $this->configLoader instanceof \alchemy\app\util\Config) { if (!$this->configLoader->isLoaded()) { $this->configLoader->load(); } } else { return false; } return $this->configLoader->getConfig(); }  public function get($name) { if ($this->getConfig() === false) { return null; } return $this->configLoader->get($name); }  public function run($mode = self::MODE_DEVELOPMENT) { if (!defined('AL_APP_DIR')) { throw new ApplicationException('No application dir set. Please use Application::setApplicationDir before use Application::run'); } Session::start(); $this->getConfig();  if ($this->pluginDir) { \alchemy\app\plugin\PluginLoader::initialize($this->pluginDir); } $request = Request::getGlobal(); $this->router->setRequestMethod($request->getMethod()); $this->router->setURI($request->getURI()); $match = $this->router->getRoute(); $this->resource = $this->router->getResource(); if ($this->onStartupHandler && $this->onStartupHandler->isCallable()) { $this->onStartupHandler->call(); } if (!$match || !$this->resource->isCallable()) { $e = new ApplicationResourceNotFoundException('No callable resource found'); EventHub::dispatch(new OnError($e)); if ($this->onErrorHandler && $this->onErrorHandler->isCallable()) {  $this->onErrorHandler->call($e); EventHub::dispatch(new OnShutdown($this)); return false; } else { throw $e; } } $this->route = $match; try {  ob_start(); $this->executeResource(); Controller::_unload(); } catch (\Exception $e) { EventHub::dispatch(new OnError($e)); if ($this->onErrorHandler && $this->onErrorHandler->isCallable()) {  $this->onErrorHandler->call($e); } else { throw $e; } } EventHub::dispatch(new OnShutdown($this)); }  protected function executeResource() { $resource = $this->resource; $className = $resource->getClassName(); $functionName = $resource->getFunctionName(); if ($resource->isObject()) { if (is_subclass_of($className, 'alchemy\app\Controller')) { $object = call_user_func(array($className,'load')); } else { $object = new $className; } $response = call_user_func(array($object, $functionName), $this->route->getParameters()); } else { $response = call_user_func(array($resource, 'call'), $this->route->getParameters()); } $contents = trim(ob_get_contents()); ob_end_clean();  if ($contents) { $response = new Response($contents); } elseif (is_string($response)) { $response = new Response($response); } elseif ($response instanceof Response) {  } elseif($response == null) { $response = new Response(''); } else { $responseType = get_class($response); throw new ApplicationException('Not a valid response type of ' . $responseType); } echo $response; }  protected $onErrorHandler;  protected $onStartupHandler;  protected $router;  protected $resource;  protected $configLoader; protected $mode = self::MODE_DEVELOPMENT;  protected static $instance;  protected $route;  protected $pluginDir; const MODE_DEVELOPMENT = 1; const MODE_PRODUCTION = 2; const VERSION = '0.9.6'; }
    class CallbackException extends \Exception {}
    class CallbackNotExistsException extends CallbackException {}
    class Callback {  public function __construct($callable) { if ($callable instanceof \Closure) { $this->isClosure = true; $this->resource = $callable; return; } elseif (is_array($callable)) { $this->isFunction = true; $this->className = $callable[0]; $this->functionName = $callable[1]; $this->resource = array(&$this->className, &$this->functionName); } elseif (is_string($callable) && !empty($callable)) { if (strstr($callable, self::INSTANCE_METHOD_SEPARATOR)) {  $callable = explode(self::INSTANCE_METHOD_SEPARATOR, $callable); $this->isObject = true; $this->className = $callable[0]; $this->functionName = $callable[1]; $this->resource = array(&$this->className, &$this->functionName); } elseif (strstr($callable, self::CLASS_METHOD_SEPARATOR)) {  $callable = explode(self::CLASS_METHOD_SEPARATOR, $callable); $this->className = $callable[0]; $this->functionName = $callable[1]; $this->resource = array(&$this->className, &$this->functionName); } else {  $this->isFunction = true; $this->functionName = $callable; $this->resource = &$this->functionName; } } else { throw new CallbackException('Expected argument to be string, closure or array,' . gettype($callable) . ' given'); } }  public function bindParameters(array $parameters) {  if ($this->isClosure) { return; } if ($this->functionName) { $this->functionName = $this->bindString($this->functionName, $parameters); } if ($this->className) { $this->className = $this->bindString($this->className, $parameters); } }  public function isCallable() { return is_callable($this->resource); } public function isClosure() { return $this->isClosure; } public function isFunction() { return $this->isFunction; } public function isObject() { return $this->isObject; } public function getClassName() { return $this->className; } public function getFunctionName() { return $this->functionName; } public function getResource() { return $this->resource; } public function setArguments(array $args) { $this->arguments = $args; } public function call() { $className = $this->getClassName(); $functionName = $this->getFunctionName(); $args = func_get_args(); if (empty($args)) { $args = $this->arguments; } if ($this->isObject()) { if (!class_exists($className)) { throw new CallbackNotExistsException('Class ' . $className . ' does not exists'); } $object = new $className(); if (!method_exists($object, $functionName)) { throw new CallbackNotExistsException('Object ' . $className . ' has not got method ' . $functionName); } return call_user_func_array(array($object, $functionName), $args); } if (!is_callable($this->resource)) { throw new CallbackNotExistsException('Non callable resource'); } return call_user_func($this->resource, $args); } private function bindString($string, $parameters) {  if (strstr($string, '$') === false) { return $string; } preg_match_all('#(\$\{([a-z0-9\-]+)\})#is', $string, $matches); $length = count($matches[0]); for ($i = 0; $i < $length; $i++) { if (!isset($parameters[$matches[2][$i]])) { continue; } $string = str_replace($matches[1][$i], $parameters[$matches[2][$i]], $string); } return $string; } const INSTANCE_METHOD_SEPARATOR = '->'; const CLASS_METHOD_SEPARATOR = '::'; private $className; private $functionName; private $isObject = false; private $isClosure = false; private $isFunction = false; private $resource; private $arguments = array(); }
    class ControllerException extends \Exception {}
    abstract class Controller extends EventDispatcher implements ILoadable {  public function onLoad() { }  public function onUnload() { }  public function dispatch(Event $e) { EventHub::dispatch($e); parent::dispatch($e); }  public static function load() { $class = get_called_class(); if (isset(self::$loaded[$class])) { return self::$loaded[$class]; } self::$loaded[$class] = new $class(); self::$loaded[$class]->onLoad(); return self::$loaded[$class]; }  public static function _unload() { foreach (self::$loaded as $c) { $c->onUnload(); } } private static $loaded = array(); }
    final class LoaderException extends \Exception {}
    final class Loader {  public static function setup() { self::register(function($className){ $path = Loader::getPathForFrameworkClass($className); if (is_readable($path)) { require_once $path; } }); }  public static function getPathForApplicationClass($className) { $className = substr($className, strpos($className, '\\')); $path = str_replace('\\', DIRECTORY_SEPARATOR, $className); return AL_APP_DIR . $path . '.php'; }  public static function getPathForFrameworkClass($className) {  $className = substr($className, strpos($className, '\\')); $path = str_replace('\\', DIRECTORY_SEPARATOR, $className); $path = AL_CORE_DIR . $path . '.php'; return $path; }  public static function register($callable) { if (!is_callable($callable)) { throw new LoaderException("Cannot register uncallable function as a loader"); } spl_autoload_register($callable); } }
    abstract class Plugin extends EventDispatcher implements plugin\IPlugin { public function onLoad() {} public function onUnload() {} public function addListener($event, $listener) { EventHub::addListener($event, $listener); parent::addListener($event, $listener); } public function dispatch(\alchemy\event\Event $event) { EventHub::dispatch($event); parent::dispatch($event); }  public static function register() { PluginLoader::_register(get_called_class()); } }
    class ViewException extends \Exception {}
    abstract class View extends EventDispatcher {  public function dispatch(Event $e) { EventHub::dispatch($e); parent::dispatch($e); } public function __set($name, $value) { $this->vars[$name] = $value; } public function __get($name) { return isset($this->vars[$name]) ? $this->vars[$name] : null; }  public function __toString() { try { $return = $this->render(); } catch (\Exception $e) { $return = $e; } return (string) $return; }  abstract public function render();  protected $vars = array(); }
}
namespace alchemy\app\event {
    use alchemy\event\Event;
    class OnError extends Event {}
    class OnShutdown extends Event {}
}
namespace alchemy\app\plugin {
    use alchemy\app\Plugin,alchemy\event\EventHub,alchemy\app\Loader;
    interface IPlugin { public static function register(); public function onLoad(); public function onUnload(); }
    class PluginLoaderException extends \Exception {}
    class PluginLoader {  public static function initialize($pluginDir = 'plugin') { $fullPluginDir = AL_APP_DIR . DIRECTORY_SEPARATOR . $pluginDir; if (!is_dir($fullPluginDir)) { if (!is_dir($pluginDir)) { throw new PluginLoaderException(sprintf('Plugin directory %s does not exists', $pluginDir)); } $fullPluginDir = $pluginDir; } $dirIterator = new \DirectoryIterator($fullPluginDir); foreach ($dirIterator as $path) { if ($path->isDir()) continue; include_once $path->getPathname(); } }  public static function _register($className) { self::$pluginList[$className] = new $className(); self::$pluginList[$className]->onLoad(); self::assignListeners(self::$pluginList[$className]); }  private static function assignListeners(Plugin $plugin) { $className = get_class($plugin); $path = Loader::getPathForApplicationClass($className);  $listenerCacheFileName = AL_APP_CACHE_DIR . '/' . sha1($path); $listeners = array();  if (is_readable($listenerCacheFileName) && filemtime($listenerCacheFileName) >= filemtime($path)) { $listeners = include_once $listenerCacheFileName; } else { $listeners = self::getListenersFromClassDefinition($className); self::saveCacheFile($listenerCacheFileName, $listeners); } foreach ($listeners as $event => $method) { EventHub::addListener($event, array($plugin, $method)); } } private static function getListenersFromClassDefinition($className) { $listeners = array(); $annotationReflection = new \alchemy\util\AnnotationReflection($className); foreach ($annotationReflection->getDeclaredMethods() as $method) { $annotation = $annotationReflection->getFromMethod($method); if (isset($annotation['OnEvent'])) { $listeners[$annotation['OnEvent']] = $method; } } return $listeners; } private static function saveCacheFile($file, $listeners) { $data = '<?php return array('; foreach ($listeners as $event => $method) { $data .= '\'' . $event . '\' => \'' . $method . '\','; } $data .= ');'; file_put_contents($file, $data); }  private static $pluginList = array(); }
}
namespace alchemy\app\util {
    class Config { public function __construct($configDir = 'config') { $this->configDir = $configDir; } public function load() { $this->loaded = true; $this->loadCrossDomainConfig(); $this->loadDomainConfig(); } protected function loadCrossDomainConfig() { $crossDomainConfigPath = $this->configDir . '/' . Config::CROSSDOMAIN_CONFIG; $this->loadConfig($crossDomainConfigPath); } protected function loadDomainConfig() { if (!defined('AL_APP_HOST')) { define('AL_APP_HOST', isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : null); } $domainConfigPath = $this->configDir . '/' . AL_APP_HOST . '.php'; $this->loadConfig($domainConfigPath); } private function loadConfig($file) { if (is_readable($file)) { $config = include_once $file; if (is_array($config)) { $this->config = array_merge($this->config , $config); } } } public function getConfig() { return $this->config; } public function isLoaded() { return $this->loaded; } public function get($name) { return isset($this->config[$name]) ? $this->config[$name] : null; } protected $loaded = false; protected $configDir; protected $config = array(); const CROSSDOMAIN_CONFIG = '*.php'; }
}
namespace alchemy\event {
    class Event {  public function __construct($callee = null) { $this->callee = $callee; }  public function stopPropagation() { $this->propagates = false; }  public function stopBubbling() { $this->bubbles = false; }  public function getCallee() { return $this->callee; }  public function _isPropagating() { return $this->propagates; }  public function _isBubbling() { return $this->bubbles; } public function __toString() { return sprintf('[Event] #%s', get_class($this)); } private $propagates = true; private $bubbles = true; private $callee; }
    class EventDispatcher {  public function addListener($event, $listener) { if (!isset($this->listeners[$event])) { $this->listeners[$event] = array(); } $this->listeners[$event][] = new Listener($listener); }  public function removeListener($event, $listener) { if (!isset($this->listeners[$event])) { return; } foreach ($this->listeners[$event] as $k => &$l) { if (!$l->isA($listener)) { continue; } unset ($this->listeners[$event][$k]); } }  public function hasListener($event, $listener) { if (!isset($this->listeners[$event])) { return false; } foreach ($this->listeners[$event] as $k => &$l) { if (!$l->isA($listener)) { continue; } return true; } return false; }  public function dispatch(Event $event) { $className = get_class($event); $list = class_parents($className); array_unshift($list, $className); $listenerExist = false; foreach ($list as $eventClass) { if (!$event->_isBubbling()) { break; } if (!isset($this->listeners[$eventClass])) { continue; } foreach ($this->listeners[$eventClass] as $listener) { $listener->call($event); $listenerExist = true; if (!$event->_isPropagating()) { break 2; } } } return $listenerExist; }  protected $listeners = array(); }
    class EventHub {  public static function initialize() { if (self::$isInitialized) { return self::$isInitialized; } self::$dispatcher = new EventDispatcher(); self::$isInitialized = true; }  public static function dispatch(Event $event) { return self::$dispatcher->dispatch($event); }  public static function addListener($event, $listener) { return self::$dispatcher->addListener($event, $listener); }  public static function hasListener($event, $listener) { return self::$dispatcher->hasListener($listener); }  public static function removeListener($event, $listener) { return self::$dispatcher->removeListener($event, $listener); }  private static $dispatcher;  private static $isInitialized = false; }
    class Listener {  public function __construct($listener) { $this->listener = $listener; }  public function call(Event $event) { if (!$this->listener || !is_callable($this->listener)) return; call_user_func($this->listener, $event); }  public function isA($listener) { return $listener == $this->listener; } private $listener; }
}
namespace alchemy\file {
    class ImageException extends \Exception{}
    class ImageFileNotFoundException extends ImageException{}
    class ImageUnsupportedTypeException extends ImageException{}
    class ImageGDNotFoundException extends ImageException{}
    class Image {  public function __construct($file, $transparency = true) {  if (!function_exists("gd_info")) { throw new ImageGDNotFoundException('GD not found in you PHP installation. Please install GD befor using this library'); } $this->transparency = $transparency; $this->file = $file; if (!file_exists($this->file) || !is_readable($this->file)) { throw new ImageFileNotFoundException(sprintf('Image file `%s` is not readable', $this->file)); }  if (function_exists('exif_imagetype')) { $type = exif_imagetype($this->file); switch ($type) { case IMAGETYPE_GIF: { $this->type = self::IMAGE_GIF; break; } case IMAGETYPE_JPEG: { $this->type = self::IMAGE_JPG; break; } case IMAGETYPE_PNG: { $this->type = self::IMAGE_PNG; break; } default: { throw new ImageUnsupportedTypeException('Image type is unspurrted'); } } }  $size = getimagesize($this->file); if (!$this->type) { switch ($size['mime']) { case 'image/jpeg': { $this->type = self::IMAGE_JPG; break; } case 'image/png': { $this->type = self::IMAGE_PNG; break; } case 'image/gif': { $this->type = self::IMAGE_GIF; break; } default: { throw new ImageUnsupportedTypeException('Image type is unspurrted'); } } } switch ($this->type) { case self::IMAGE_JPG: { $this->image = imagecreatefromjpeg($this->file); break; } case self::IMAGE_GIF: { $this->image = imagecreatefromgif($this->file); if ($this->transparency) $this->preserveTransparency($this->image); break; } case self::IMAGE_PNG: { $this->image = imagecreatefrompng($this->file); if ($this->transparency) $this->preserveTransparency($this->image); break; } } $this->currentWidth = $size[0]; $this->currentHeight = $size[1]; } public function __destruct() { if (is_resource($this->image)) { imagedestroy($this->image); } }  public function getWidth() { return $this->currentWidth; }  public function getHeight() { return $this->currentHeight; }  public function resize($width = null, $height = null, $resizeType = self::RESIZE_MAXIMAL) { if (!$width && !$height) { throw new ImageException(__CLASS__ . '::' . __METHOD__ . '() expect width or/and height parameter(s) but none passed'); } $image = $this->image; if ($resizeType == self::RESIZE_MAXIMAL) { $newSize = $this->calculateNewImageSize($width, $height); } else { $newSize = $this->calculateNewMinImageSize($width, $height); } $this->image = $this->createRawImage($newSize['width'], $newSize['height']); imagecopyresampled($this->image, $image, 0, 0, 0, 0, $newSize['width'], $newSize['height'], $this->currentWidth, $this->currentHeight); $this->currentWidth = $newSize['width']; $this->currentHeight = $newSize['height']; return $this; } private function calculateNewMinImageSize($minWidth, $minHeight) { if (!$minHeight || !$minWidth) { throw new ImageException('Expecting both width and height when using flag Image::RESIZE_MINIMAL'); } $newSize = array('width' => $this->currentWidth, 'height' => $this->currentHeight); $newSize = $this->calculateNewImageSizeByWidth($minWidth); if ($minHeight > $newSize['height']) { $newSize = $this->calculateNewImageSizeByHeight($minHeight); } return $newSize; }  public function crop($startX, $startY, $width, $height) {  $width > $this->currentWidth ? $width = $this->currentWidth : false; $height > $this->currentHeight ? $height = $this->currentHeight : false; $startX + $width > $this->currentWidth ? $startX = $this->currentWidth - $width : false; $startY + $height > $this->currentHeight ? $startY = $this->currentHeight - $width : false; $startY < 0 ? $startY = 0 : false; $startX < 0 ? $startX = 0 : false; $image = $this->image; $this->image = $this->createRawImage($width, $height); imagecopyresampled($this->image, $image, 0, 0, $startX, $startY, $width, $height, $width, $height); $this->currentHeight = $height; $this->currentWidth = $width; return $this; }  public function rotate($rotate = 'CW') { switch ($rotate) { case 'CW': { $this->image = imagerotate($this->image, -90, 0); break; } case 'CCW': default: { $this->image = imagerotate($this->image, 90, 0); break; } } $width = $this->currentWidth; $this->currentWidth = $this->currentHeight; $this->currentHeight = $width; return $this; }  public function cropFromCenter($width, $height) { $startX = round(($this->currentWidth - $width) / 2); $startY = round(($this->currentHeight - $height) / 2); return $this->crop($startX, $startY, $width, $height); }  public function flip() { $xLength = imagesx($this->image); $yLength = imagesy($this->image); $image = $this->image; $this->image = $this->createRawImage($this->currentWidth, $this->currentHeight); for ($x = 0; $x < $xLength; $x++) { for ($y = 0; $y < $yLength; $y++) { imagecopy($this->image, $image, $xLength - $x - 1, $y, $x, $y, 1, 1); } } return $this; }  public function save($compression = 100, $file = null) { switch ($this->type) { case self::IMAGE_GIF: { if ($file) { imagegif($this->image, $file); } else { imagegif($this->image, $this->file); } break; } case self::IMAGE_JPG: { if ($file) { imagejpeg($this->image, $file, $compression); } else { imagejpeg($this->image, $this->file, $compression); } break; } case self::IMAGE_PNG: { $compression = round($compression / 10); $compression >= 10 ? $compression = 9 : null; $compression = 9 - $compression; if ($file) { imagepng($this->image, $file, $compression); } else { imagepng($this->image, $this->file, $compression); } break; } } }  public function display($compression = 100) { switch ($this->type) { case self::IMAGE_GIF: { header('Content-type: image/gif'); imagegif($this->image); break; } case self::IMAGE_JPG: { header('Content-type: image/jpeg'); imagejpeg($this->image, null, $compression); break; } case self::IMAGE_PNG: { header('Content-type: image/png'); $compression = round($compression / 10); $compression >= 10 ? $compression = 9 : null; $compression = 9 - $compression; imagepng($this->image, null, $compression); break; } } }  private function calculateNewImageSize($maxWidth, $maxHeight) { $newSize = array('width' => $this->currentWidth, 'height' => $this->currentHeight); if ($maxWidth && $maxWidth > 0) { $newSize = $this->calculateNewImageSizeByWidth($maxWidth); if ($maxHeight && $maxHeight > 0 && $newSize['height'] > $maxHeight) { $newSize = $this->calculateNewImageSizeByHeight($maxHeight); }  } if ($maxHeight && $maxHeight > 0) { $newSize = $this->calculateNewImageSizeByHeight($maxHeight); if ($maxWidth && $maxWidth > 0 && $newSize['width'] > $maxWidth) { $newSize = $this->calculateNewImageSizeByWidth($maxWidth); } } return $newSize; }  private function calculateNewImageSizeByWidth($width) { $prop = $width / $this->currentWidth; $newHeight = $this->currentHeight * $prop; return array('width' => $width, 'height' => ceil($newHeight)); }  private function calculateNewImageSizeByHeight($height) { $prop = $height / $this->currentHeight; $newWidth = $this->currentWidth * $prop; return array('width' => ceil($newWidth), 'height' => $height); } private function preserveTransparency(&$img) {  imagealphablending($img, false); imagesavealpha($img, true); } private function createRawImage($width, $height) { if (function_exists('imagecreatetruecolor')) { $img = imagecreatetruecolor($width, $height); } else { $img = imagecreate($width, $height); } if ($this->type != self::IMAGE_PNG && $this->type != self::IMAGE_GIF) { return $img; } if (!$this->transparency) { return $img; }  $this->preserveTransparency($img); $transparent = imagecolorallocatealpha($img, 255, 255, 255, 127); imagefilledrectangle($img, 0, 0, $width, $height, $transparent); return $img; } protected $file; protected $type; protected $image; private $transparency = true; const IMAGE_PNG = 1; const IMAGE_JPG = 2; const IMAGE_GIF = 3;  const IMAGE_BMP = 4; const RESIZE_MINIMAL = 1; const RESIZE_MAXIMAL = 2; }
}
namespace alchemy\future\app\router {
    use alchemy\http\RouterException;
    class RouteException extends \Exception {}
    class Route {  public function __construct($pattern) { $this->pattern = trim($pattern, self::$separator); }  public function isMatch($uri) { $this->data = array(); $this->parse(); foreach ($this->matchers as $matcher) { if (preg_match('#^' . $matcher . '$#i', $uri, $values)) { if (!empty($values)) {  array_shift($values);  if (!empty($values)) { $length = count($values); $this->data = array_combine(array_slice($this->params, 0, $length), $values); } } return true; } } return false; } protected function parse() { if ($this->parsed) { return; } if ($this->pattern == self::WILD_CARD) { $this->matchers[] = '.*'; return; } $parts = explode(self::$separator, $this->pattern); $regex = ''; $paramCount = 0; foreach ($parts as $part) {  if (substr($part, -1) == '?') { $part = substr($part,0,-1); $this->matchers[] = $regex; $this->matchersParamCount[] = $paramCount; } $params = array(); $part = preg_replace_callback('#' . self::PARAM_REGEX . '#', function($match) use (&$params, &$paramCount) { if (isset($match[2])) { if (strpos($match[2], ')') != false || strpos($match[2] , '(') != false) { throw new RouteException('Cannot use `(` & `)` in route pattern definition'); } $regex = '(' . substr($match[2],1) . ')'; } else { $regex = '([^\/]+?)'; } $params[] = $match[1]; ++$paramCount; return $regex; }, $part);  $regex .= '\\' . self::$separator . $part; $this->params = array_merge($this->params, $params); } $this->matchersParamCount[] = $paramCount; $this->matchers[] = $regex; $this->parsed = true; } public function getData() { return $this->data; } private $pattern; private $params = array(); private $matchers = array(); private $matchersParamCount = array(); private $parsed = false; private $data = array(); protected static $separator = '/'; const WILD_CARD = '*'; const PARAM_REGEX = '\$\{([a-z0-9\-]+)(\:[^\/]+?)?\}'; }
}
namespace alchemy\future\app {
    use alchemy\app\Callback,alchemy\future\app\router\Route;
    class Router {  public function addRoute($pattern, $callback) { if (!isset($this->routes[$callback])) { $this->routes[$callback] = array(); } $this->routes[$callback][] = new Route($pattern); } public function addTranslator($callable) { }  public function getCallback($uri) { foreach ($this->routes as $callback => $routes) { foreach ($routes as $route) { if ($route->isMatch($uri)) { $callback = new Callback($callback); $data = $route->getData(); $callback->bindParameters($data); $callback->setArguments(array($data)); return $callback; } } } }  public function getURI($callable, $data = array()) { } protected $routes = array(); protected $translators = array(); }
}
namespace alchemy\future {
    class Mail { public function __construct($to = null, $subject = null, $body = null) { } public function setBody($body) { } public function getBody() { } public function setSubject($subject) { } public function getSubject() { } public function setFrom($from) { } public function getFrom() { } public function setTo($to) { } public function getTo() { } public function setCC($cc) { } public function getCC() { } public function attachFiles($file) { } public function getAttachedFiles() { } public function send() { } }
}
namespace alchemy\future\template\html\form {
    use alchemy\security\ValidatorasBaseValidator;
    class CheckBox extends Input { public function __construct($label = '', Validator $validator = null) { parent::__construct($label, $validator); } public function __toString() { return sprintf(self::TEMPLATE, ($this->value == $this->chckValue ? 'checked="checked"' : ''), $this->chckValue, $this->attributesToString('value')); } const TEMPLATE = '<input type="checkbox" %s value="%s" %s />'; private $chckValue = 1; }
    class Hidden extends Input { public function __toString() { return sprintf(self::TEMPLATE, $this->attributesToString()); } const TEMPLATE = '<input type="hidden" %s />'; }
    abstract class Input { public function __construct($label = '', Validator $validator = null) { $this->label = $label; } public function setCSS($css) { $this->style = $css; } public function addCSSClass($class) { $class = explode(' ', $class); $diff = array_diff($class, $this->css); $this->css = array_merge($this->css, $diff); $this->attributes['class'] = implode(' ', $this->css); } public function removeCSSClass($class) { if ($class == '*') { if (isset($this->attributes['css'])) { unset($this->attributes['css']); } return $this->css = array(); } $class = explode(' ', $class); foreach ($class as $c) { $key = array_search($c, $this->css); if ($key) { unset($this->css[$key]); } } } public function setId($id) { $this->id = $id; $this->attributes['id'] = $id; } public function getId() { return $this->id; } public function setValidator(Validator $validator, $errorMessage = null) { if ($errorMessage) { $validator->setMessage(htmlspecialchars($errorMessage)); } $this->validator = $validator; } public function getValidator() { return $this->validator; } public function validate() { $this->isValidated = true; if (!$this->validator) { $this->isValid = true; return true; } if (!$this->validator->validate($this->value)) { $this->isValid = false; $this->attributes['data-on-error'] = $this->errorMessage; $this->addCSSClass('OnError'); return false; } $this->isValid = true; $this->addCSSClass('OnSuccess'); return true; } public function getValue() { return $this->value; } public function setValue($value) { $value = htmlentities($value); $this->value = $value; $this->attributes['value'] = $value; } public function setName($name) { $this->name = $name; $this->attributes['name'] = $name; } public function getName() { return $this->name; } public function setAttribute($attr, $value) { $attr = strtolower((string)$attr); $value = (string)$value; switch ($attr) { case 'style': { $this->setCSS($value); break; } case 'class': { $value = explode(' ', $value); $this->css = $value; $this->attributes['css'] = $value; break; } case 'id': { $this->setId($value); break; } case 'name': { $this->setName($value); break; } case 'value': { $this->setValue($value); break; } default: { if (!$value) unset($this->attributes[$attr]); $this->attributes[$attr] = $value; break; } } } public function getLabel() { return $this->label; } public function setLabel($label) { return $this->label = $label; } public function getAttribute($attr) { if (!key_exists($attr, $this->attributes)) return null; return $this->attributes[$attr]; } protected function attributesToString($exclude = array()) { if (!is_array($exclude)) { $exclude = array($exclude); } $string = ''; foreach ($this->attributes as $attr => $value) { if (in_array($attr, $exclude)) continue; $string .= ' ' . $attr . '="' . addslashes($value) . '"'; } return $string; } protected $css = array(); protected $style; protected $id;  protected $validator; protected $isValidated; protected $isValid; protected $value; protected $name; protected $attributes = array(); protected $errorMessage; protected $label; }
    class Password extends Input { public function __toString() { return sprintf(self::TEMPLATE, $this->attributesToString()); } const TEMPLATE = '<input type="password" %s />'; }
    class SelectList extends Input { public function setData($list) { $this->list = $list; } public function getData() { return $this->list; } public function __toString() { $selectValue = $this->getValue(); $options = ''; foreach ($this->list as $name => $value) { if (is_array($value)) { $options .= '<optgroup label="' . $name . '">'; foreach($value as $optgroupName => $optgroupValue) { $options .= '<option ' . ($selectValue == $optgroupName ? 'selected="selected"' : '') . ' value="' . $optgroupName . '">' . $optgroupValue . '</option>'; } $options .= '</optgroup>'; continue; } $options .= '<option ' . ($selectValue == $name ? 'selected="selected"' : '') . ' value="' . $name . '">' . $value . '</option>'; }  return sprintf(self::TEMPLATE, $this->attributesToString('value'), $options); } private $list = array(); const TEMPLATE = '<select %s>%s</select>'; }
    class TextArea extends Input { public function __toString() { return sprintf(self::TEMPLATE, $this->attributesToString('value'), htmlentities($this->value)); } const TEMPLATE = '<textarea %s>%s</textarea>'; }
    class TextInput extends Input { public function __toString() { return sprintf(self::TEMPLATE, $this->attributesToString()); } const TEMPLATE = '<input type="text" %s />'; }
    class ValidatorException extends \Exception {}
    class UnknownValidatorException extends ValidatorException {}
    class Validator {  public function __construct($type, array $options = null) { if (!isset(self::$validatorList[$type])) { throw new UnknownValidatorException('Unknown validator type: ' . $type); } $this->options = $options; if (isset($options['error_msg'])) { $this->message = $options['error_msg']; unset($options['error_msg']); } } public function validate($input) { BaseValidator::validate($input, $this->type, $this->options); } public function setMessage($msg) { $this->message = $msg; } public function getMessage() { return $this->message; } protected $type; protected $message; protected $options; protected static $validatorList = array( BaseValidator::VALIDATE_CREDITCARD => 1, BaseValidator::VALIDATE_DATE => 1, BaseValidator::VALIDATE_EMAIL => 1, BaseValidator::VALIDATE_IP => 1, BaseValidator::VALIDATE_NUMBER => 1, BaseValidator::VALIDATE_REGEXP => 1, BaseValidator::VALIDATE_STRING => 1, BaseValidator::VALIDATE_URL => 1 ); }
}
namespace alchemy\future\template\html {
    use alchemy\storage\Session,alchemy\future\template\html\form\Hidden;
    class Form implements \Iterator {  public function __construct($name, $salt = null) { $this->session = &Session::get('AlchemyFormHelper:' . $name); $this->previousSalt = $this->session['salt']; if (!$salt) { $salt = sha1(time() . mt_rand(1, 1000)); } $input = new Hidden(); $input->setName($salt); $input->setValue(1); $this->session['salt'] = $salt; $this->saltItem = $input; }  public function __get($name) { return $this->input[$name]; }  public function __set($name, form\Input $value) { $value->setName($name); $this->input[$name] = $value; }  public function rewind() { reset($this->input); } public function current() { return current($this->input); } public function key() { return key($this->input); } public function next() { return next($this->input); } public function valid() { return current($this->input) instanceof form\Input; }   public function isSubmited() { if($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_POST[$this->previousSalt]) && $_POST[$this->previousSalt] == 1) { return true; } return false; } public function isValid() { $valid = true; $this->fetch($_POST); foreach ($this->input as $i) { if(!$i->validate()) { $this->lastError = $i->getValidator()->getMessage(); $valid = false; } } return $valid; } public function getLastError() { return $this->lastError; } public function fetch($data) { if (is_object($data)) $data = get_object_vars($data); foreach ($data as $name => $value) { if (isset($this->input[$name])) { $this->input[$name]->setValue($value); } } } public function __toString() { return '' . $this->saltItem; } protected $session; protected $previousSalt; protected $lastError; protected $input;  private $saltItem; }
}
namespace alchemy\http {
    use alchemy\app\Callback,alchemy\http\router\Route;
    class Headers implements \Iterator, \ArrayAccess { public function __construct(array $headers = array()) { $this->headers = $headers; } public function set($name, $value) { if (!isset(self::$validHeaders[$name])) { return; } $this->headers[$name] = $value; }  public static function parseAccept($accept) { $data = array(); $item = 0; $accept = explode(',', $accept); foreach ($accept as $info) { $data[$item++] = array(); $current = &$data[key($data)]; $info = explode(';', $info); $current['type'] = trim($info[0]); array_shift($info); foreach ($info as $i) { $i = explode('=', $i); $current[trim($i[0])] = trim($i[1]); } if (!isset($current['q'])) { $current['q'] = 1; } next($data); }  usort($data, function($a, $b){ if ($a['q'] == $b['q']) { return 0; } return ($a['q'] < $b['q']) ? 1 : -1; }); return $data; }  public function avoidCacheControl() { $this->headers[self::HEADER_CACHE_CONTROL] = 'no-cache, must-revalidate'; $this->headers[self::HEADER_EXPIRES] = 'Expires: Sat, 26 Jul 1997 05:00:00 GMT'; } public function repairP3P() { $this->headers[self::HEADER_P3P] = 'CP="NOI ADM DEV COM NAV OUR STP"'; } public function hideEnvironment() { $this->headers[self::HEADER_SERVER] = ''; $this->headers[self::HEADER_X_POWERED_BY] = ''; } public function setExpiration($expire) { $this->headers[self::HEADER_EXPIRES] = $expire; } public function setContentType($type) { $this->headers[self::HEADER_CONTENT_TYPE] = $type; } public function getContentType() { return $this->headers[self::HEADER_CONTENT_TYPE]; }  public function send() { if (headers_sent()) { return false; } foreach ($this as $header => $value) { header($header . ': ' . $value); } } public function offsetExists($offset) { return isset($this->headers[$offset]); } public function offsetGet($offset) { return $this->headers[$offset]; } public function offsetSet($offset, $value) { if (!isset(self::$validHeaders[$offset])) { return false; } $this->headers[$offset] = $value; return true; } public function offsetUnset($offset) { unset($this->headers[$offset]); }  public function current() { return current($this->headers); }  public function next() { return next($this->headers); }  public function key() { return key($this->headers); }  public function valid() { $valid = key($this->headers); return $valid !== null && $valid !== false; }  public function rewind() { reset($this->headers); } public function toArray() { return $this->headers; } private $headers = array();  const HEADER_HOST = 'Host';  const HEADER_CONNECTION = 'Connection';  const HEADER_USER_AGENT = 'User-Agent';  const HEADER_CACHE_CONTROL = 'Cache-Control';  const HEADER_ACCEPT_ENCODING = 'Accept-Encoding';  const HEADER_ACCEPT_LANGUAGE = 'Accept-Language';  const HEADER_ACCEPT_CHARSET = 'Accept-Charset';  const HEADER_P3P = 'P3P';  const HEADER_CONTENT_ENCODING = 'Content-Encoding'; const HEADER_CONTENT_LENGTH = 'Content-Length';  const HEADER_EXPIRES = 'Expires';  const HEADER_X_POWERED_BY = 'X-Powered-By';  const HEADER_SERVER = 'Server';  const HEADER_LOCATION = 'Location';  const HEADER_LAST_MODIFIED = 'Last-Modified';  const HEADER_DATE = 'Date';  const HEADER_CONTENT_TYPE = 'Content-Type';  const HEADER_ALLOW = 'Allow';  const HEADER_ACCESS_CONTROL_ALLOW='Access-Control-Allow-Origin';  const HEADER_CONTENT_DISPOSITION = 'Content-Disposition';  const HEADER_AUTHORIZATION = 'Authorization';  const HEADER_PROXY_AUTHORIZATION = 'Proxy-Authorization';  const HEADER_COOKIE = 'Cookie';  const HEADER_SET_COOKIE = 'Set-Cookie'; const ENCODING_GZIP = 'gzip'; const ENCODING_DEFLATE = 'deflate';  const CONTENT_TYPE_TEXT = 'text/plain'; const CONTENT_TYPE_JAVASCRIPT = 'application/x-javascript'; const CONTENT_TYPE_JSON = 'application/json'; const CONTENT_TYPE_RICHTEXT = 'text/richtext'; const CONTENT_TYPE_JPEG = 'image/jpeg'; const CONTENT_TYPE_PNG = 'image/png'; const CONTENT_TYPE_SVG = 'image/svg+xml'; const CONTENT_TYPE_GIF = 'image/gif'; const CONTENT_TYPE_ZIP = 'application/zip'; const CONTENT_TYPE_PDF = 'application/pdf'; const CONTENT_TYPE_MP3 = 'audio/mpeg'; const CONTENT_TYPE_BMP = 'image/bmp'; const CONTENT_TYPE_MPEG = 'video/mpeg'; protected static $validHeaders = array ( self::HEADER_USER_AGENT => 1, self::HEADER_ACCEPT_CHARSET => 1, self::HEADER_ACCEPT_ENCODING => 1, self::HEADER_ACCEPT_LANGUAGE => 1, self::HEADER_ACCESS_CONTROL_ALLOW => 1, self::HEADER_ALLOW => 1, self::HEADER_CACHE_CONTROL => 1, self::HEADER_COOKIE => 1, self::HEADER_CONNECTION => 1, self::HEADER_CONTENT_DISPOSITION => 1, self::HEADER_CONTENT_ENCODING => 1, self::HEADER_CONTENT_LENGTH => 1, self::HEADER_CONTENT_TYPE => 1, self::HEADER_DATE => 1, self::HEADER_EXPIRES => 1, self::HEADER_HOST => 1, self::HEADER_LOCATION => 1, self::HEADER_LAST_MODIFIED => 1, self::HEADER_P3P => 1, self::HEADER_SERVER => 1, self::HEADER_SET_COOKIE => 1, self::HEADER_USER_AGENT => 1, self::HEADER_X_POWERED_BY => 1, self::HEADER_AUTHORIZATION => 1, self::HEADER_PROXY_AUTHORIZATION => 1 ); }
    class RequestException extends \Exception {}
    class Request {  public static function getGlobal() { if (!(self::$globalRequest instanceof Request)) {  $headers = array( 'Host' => isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : null, 'Connection' => isset($_SERVER['HTTP_CONNECTION']) ? $_SERVER['HTTP_CONNECTION'] : null, 'User-Agent' => isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : null, 'Cache-Control' => isset($_SERVER['HTTP_CACHE_CONTROL']) ? $_SERVER['HTTP_CACHE_CONTROL'] : null, 'Accept-Encoding' => isset($_SERVER['HTTP_ACCEPT_ENCODING']) ? $_SERVER['HTTP_ACCEPT_ENCODING'] : null, 'Accept-Language' => isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : null, 'Accept-Charset' => isset($_SERVER['HTTP_ACCEPT_CHARSET']) ? $_SERVER['HTTP_ACCEPT_CHARSET'] : null );  $requestData = array(); switch ($_SERVER['REQUEST_METHOD']) { case self::METHOD_POST: $requestData = $_POST; break; case self::METHOD_PUT: $requestData = file_get_contents("php://input"); break; case self::METHOD_GET: $requestData = $_GET; break; default: $requestData = $_REQUEST; break; } self::$globalRequest = new self($_SERVER['REQUEST_URI'], $_SERVER['REQUEST_METHOD'], $requestData, new Headers($headers));  self::$globalRequest->isXHR(isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest');  if (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) { self::$globalRequest->isSecure(true); } } return self::$globalRequest; }  public function __construct($url, $method = self::METHOD_GET, $data = array(), Headers $headers = null) { $url = parse_url($url); $this->uri = isset($url['path']) ? $url['path'] : '/'; if (isset($url['query'])) { parse_str($url['query'], $this->query); } $this->data = $data; if (isset($url['scheme'])) { $this->scheme = $url['scheme']; } if (isset($url['host'])) { $this->host = $url['host']; } $this->method = $method; $this->headers = $headers; }  public function isPost() { return $this->getMethod() == self::METHOD_POST; }  public function isGet() { return $this->getMethod() == self::METHOD_GET; }  public function isDelete() { return $this->getMethod() == self::METHOD_DELETE; }  public function isPut() { return $this->getMethod() == self::METHOD_PUT; }  public function isXHR($set = null) { if ($set !== null) { $this->isXHR = $set; } return $this->isXHR; }  public function getQuery() { return $this->query; }  public function setQuery(array $query) { $this->query = $query; }  public function send($timeout = null) {  $url = $this->scheme . '://' . $this->host . $this->uri . (empty($this->query) ? '' : '?' . http_build_query($this->query)); $options = array( CURLOPT_RETURNTRANSFER => true, CURLOPT_HEADER => true ); if ($timeout) { $options[CURLOPT_TIMEOUT_MS] = $timeout; } if (!empty($this->data)) { $options[CURLOPT_POST] = 1; $options[CURLOPT_POSTFIELDS] = $this->data; } if ($this->method == self::METHOD_PUT) { $options[CURLOPT_PUT] = 1; $options[CURLOPT_BINARYTRANSFER] = 1; } if ($this->caFile) { $this->verifyPeer = true; $options[CURLOPT_CAINFO] = $this->caFile; } $options[CURLOPT_SSL_VERIFYPEER] = $this->verifyPeer; $options[CURLOPT_SSL_VERIFYHOST] = $this->verifyPeer; if ($this->headers) { $options[CURLOPT_HTTPHEADER] = $this->headers->toArray(); }  $handler = curl_init($url); curl_setopt_array($handler, $options); $result = curl_exec($handler); $info = curl_getinfo($handler); $errorNo = curl_errno($handler); $errorMessage = curl_error($handler); curl_close($handler); if ($errorNo !== 0) { throw new RequestException($errorMessage, $errorNo); } $header = explode("\n", substr($result, 0, $info['header_size'])); $body = substr($result, $info['header_size']);  $version = substr($header[0],5,3); array_shift($header); $headers = new Headers(); foreach ($header as $h) { $pos = strpos($h, ':'); if (!$pos) { continue; } $headers->set(substr($h, 0, $pos), substr($h, $pos + 2)); } $response = new Response($body, $info['http_code']); $response->setVersion($version); return $response; }  public function setCookieJar($file) { $this->cookieJar = $file; }  public function setData($data) { $this->data = $data; }  public function getData() { return $this->data; } public function setVerifyPeer($verify = true) { $this->verifyPeer = $verify; } public function setCAFile($filename) { if (!is_readable($filename)) { throw new RequestException(sprintf('Cert info file `%s` is not readable', $filename)); } $this->caFile = $filename; }  public function isSecure($set = null) { if ($set !== null) { if ($set) { $this->scheme = 'https'; } else { $this->scheme = 'http'; } } return $this->scheme == 'https'; }  public function getScheme() { return $this->scheme; } public function setScheme($scheme = 'http') { $this->scheme = $scheme; } public function getMethod() { return $this->method; } public function setHeaders(Headers $headers) { $this->headers = $headers; } public function getHeader($header) { return $this->headers[$header]; } public function getAllHeaders() { return $this->headers; } public function getURI() { return $this->uri; }  protected $query = array();  protected $uri = '/';  protected $host;  protected $data = array();  protected $method;  protected $isXHR = false;  protected $scheme = 'http';  protected $headers;  protected $verifyPeer = false;  protected $cookieJar; protected $caFile;  private static $globalRequest; const METHOD_GET = 'GET'; const METHOD_POST = 'POST'; const METHOD_PUT = 'PUT'; const METHOD_DELETE = 'DELETE'; }
    class Response { public function __construct($body, $status = 200, Headers $headers = null) { $this->body = $body; $this->status = $status; if ($headers) { $this->setHeaders($headers); } } public function setHeaders(Headers $headers) { $this->headers = $headers; } public function getHeaders() { return $this->headers; } public function getVersion() { return $this->version; } public function setVersion($version) { $this->version = $version; } protected function sendStatusHeader() { if (!headers_sent()) { header(sprintf('HTTP/%s %s %s', $this->version, $this->status, self::$statusCodes[$this->status])); } } public function send() { $this->sendStatusHeader(); if ($this->headers) { $this->headers->send(); } echo $this->body; } public function __toString() { header(sprintf('HTTP/%s %s %s', $this->version, $this->status, self::$statusCodes[$this->status])); if ($this->headers) { $this->headers->send(); } return $this->body . ''; }  protected $headers;  protected $body; protected $status = 200; protected $version = '1.1'; protected static $statusCodes = array ( 100 => 'Continue', 101 => 'Switching Protocols', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported' ); }
    class RouterException extends \Exception {}
    class RouterInvalidRequestMethodException extends RouterException {}
    class Router {  public function getRoute() { $this->processRouteSearch(); return $this->currentRoute; }  public function setForceMode() { $this->forceMode = true; }  public function getResource() { $this->processRouteSearch(); return $this->currentResource; } public function setURI($uri) { $this->uri = $uri; } public function findURI($resource, $options = array()) { } public function setRequestMethod($method = Request::METHOD_GET) { if (!isset(self::$validRequestMethods[$method])) { throw new RouterInvalidRequestMethodException(sprintf('Method `%s` is not a valid request method', $method)); } $this->method = $method; }  public function addResource($route, $resource) { $pos = strpos($route, ' '); if ($pos === false || $pos == 0) { $method = self::WILD_CARD; $path = $route; } else { $method = strtoupper(substr($route, 0, $pos)); if (!isset(self::$validRequestMethods[$method])) { throw new RouterInvalidRequestMethodException(sprintf('Method `%s` is not a valid request method', $route[0])); } $path = substr($route, $pos + 1); } $resource = new Callback($resource); $this->routes[$method][$path] = $resource; $this->resources[$resource->getClassName()][$resource->getFunctionName()] = $route; } private function processRouteSearch() { if (!$this->forceMode && $this->currentRoute && $this->currentResource) { return true; }  foreach ($this->routes[$this->method] as $route => $resource) { $r = new router\Route($route);   if (!$r->isMatch($this->uri) || $route == self::WILD_CARD) { continue; } $this->currentResource = $resource; $this->currentResource->bindParameters($r->getParameters()); $this->currentRoute = $r; return true; }  if (isset($this->routes[$this->method][self::WILD_CARD])) { $this->currentRoute = new router\Route(self::WILD_CARD); $this->currentResource = $this->routes[$this->method][self::WILD_CARD]; return true; }  if ($this->method == self::WILD_CARD) return false; foreach ($this->routes[self::WILD_CARD] as $route => $resource) { $r = new router\Route($route); if (!$r->isMatch($this->uri) || $route == self::WILD_CARD) { continue; } $this->currentResource = $resource; $this->currentResource->bindParameters($r->getParameters()); $this->currentRoute = $r; return true; }  if (isset($this->routes[self::WILD_CARD][self::WILD_CARD])) { $this->currentRoute = new router\Route(self::WILD_CARD); $this->currentResource = $this->routes[self::WILD_CARD][self::WILD_CARD]; return true; } return false; } const WILD_CARD = '*'; protected static $validRequestMethods = array ( self::WILD_CARD => 1, Request::METHOD_POST => 1, Request::METHOD_PUT => 1, Request::METHOD_GET => 1, Request::METHOD_DELETE => 1 );  private $uri;  private $method = Request::METHOD_GET;  private $currentRoute;  private $currentResource; private $forceMode = false;  private $routes = array( self::WILD_CARD => array(), Request::METHOD_POST => array(), Request::METHOD_PUT => array(), Request::METHOD_GET => array(), Request::METHOD_DELETE => array() ); private $resources = array(); }
}
namespace alchemy\http\router {
    class Route { public function __construct($pattern) { if ($pattern == self::WILD_CARD) { $this->pattern = '.*'; return; } $this->parseUrlPattern($pattern); } public function __get($param) { if (!isset($this->params[$param])) { return null; } return $this->params[$param]; } public static function setSeparator($separator = '/') { self::$separator = $separator; } public function getPattern() { return $this->pattern; } public function getParameters() { return $this->params; }  public function isMatch($uri) { $match = preg_match('#' . $this->regex . '#', $uri, $matches); if (!$match) { return false; } $length = count ($matches); $paramKeys = array_keys($this->params);  for ($i = 1; $i < $length; $i++) { $value = $matches[$i]; $this->params[$paramKeys[$i - 1]] = $value; } return true; } private function parseUrlPattern($pattern) { $separator = self::$separator; $pattern = rtrim($pattern, $separator); $this->pattern = $pattern;  $pattern = str_replace($separator, '\\' . $separator, $pattern); $route = $this; $pattern = preg_replace_callback('#' . self::PATTERN_REGEX . '#', function($match) use ($route) { if (isset($match[2])) { $regex = '(' . substr($match[2],1) . ')'; } else { $regex = '([^\/]+?)'; } $route->_registerParam($match[1]); unset($route); return $regex; }, $pattern); $this->regex = '^' . $pattern . '\/?$'; }  public function _registerParam($paramName) { $this->params[$paramName] = null; }  private $regex; private $pattern;  private $params = array(); protected static $separator = '/'; const WILD_CARD = '*'; const PATTERN_REGEX = '\{\$([a-z0-9\-]+)[\\\]?(\:[^\/]+)?\}'; }
}
namespace alchemy\object {
    interface ILoadable { public static function load(); }
}
namespace alchemy\security\acl {
    class Role { public function __construct() { $this->restrictions['*'] = array(); $this->restrictions['*']['*'] = false; }  public function allow($resource) { if ($resource == '*') { $resource = array('*','*'); } else { $resource = explode('.', $resource); } $controller = $resource[0]; $action = isset($resource[1]) ? $resource[1] : '*'; if (!isset($this->restrictions[$controller])) { $this->restrictions[$controller] = array(); $this->restrictions[$controller]['*'] = false; } $this->restrictions[$controller][$action] = true; $this->restrictions[$controller]['?'] = true; return $this; }  public function deny($resource) { if ($resource == '*') { $resource = array('*','*'); } else { $resource = explode('.', $resource); } $controller = $resource[0]; $action = isset($resource[1]) ? $resource[1] : '*'; if (!isset($this->restrictions[$controller])) { $this->restrictions[$controller] = array(); $this->restrictions[$controller]['*'] = false; $this->restrictions[$controller]['?'] = false; } $this->restrictions[$controller][$action] = false; return $this; }  public function hasAccess($resource) { $resource = explode('.', $resource); $resource[1] = isset($resource[1]) ? $resource[1] : '*'; if (!isset($this->restrictions[$resource[0]])) { return $this->restrictions['*']['*']; } if (!isset($this->restrictions[$resource[0]][$resource[1]])) { return $this->restrictions[$resource[0]]['*']; } return $this->restrictions[$resource[0]][$resource[1]]; }  public function getRestrictionMeta() { return $this->restrictions; } private $restrictions = array(); }
}
namespace alchemy\security {
    use alchemy\security\acl\Role,alchemy\storage\Session;
    class AclException extends \Exception {}
    class AccessDeniedException extends AclException {}
    class Acl {  public static function defineRole($name = Acl::ACL_DEFAULT) { return self::$definedRoles[$name] = new Role(); }  public static function addRole($name) { if (!self::roleExists($name)) return false; self::$cache = array(); self::$attachedRoles[$name] = $name; return true; }  public static function getRoles() { return self::$attachedRoles; }  public static function removeRole($name) { if (self::hasRole($name)) { self::$cache = array(); unset(self::$attachedRoles[$name]); } }  public static function hasRole($name) { return isset(self::$attachedRoles[$name]); }  public static function roleExists($name) { return isset(self::$definedRoles[$name]); }  public static function isAllowed($resource) {  $access = false; foreach (self::$attachedRoles as $role) { $role = self::$definedRoles[$role]; if (!$role->hasAccess($resource)) { continue; } $access = true; break; } self::$cache[$resource] = $access; return $access; }  public static function forget() { self::$attachedRoles = array(); self::$cache = array(); self::addRole(self::ACL_DEFAULT); } public static function setup() {  self::defineRole()->deny('*'); $acl = Session::get('acl'); self::$attachedRoles = &$acl['user_roles']; self::$cache = &$acl['cache']; if (!count(self::$attachedRoles)) { self::$attachedRoles = array(); self::addRole(self::ACL_DEFAULT); } if (!self::$cache) self::$cache = array(); } const ACL_DEFAULT = 'DefaultRole'; private static $attachedRoles = array(); private static $definedRoles = array(); private static $cache = array(); }
    class Validator {  public static function validate($input, $validator, array $options = null) { switch ($validator) { case self::VALIDATE_DATE: { return self::date($input, $options); } case self::VALIDATE_NUMBER: { return self::number($input, $options); } case self::VALIDATE_STRING: { return self::string($input, $options); } case self::VALIDATE_EMAIL: { return self::email($input); } case self::VALIDATE_IP: { return self::ip($input); } case self::VALIDATE_URL: { return self::url($input); } case self::VALIDATE_REGEXP: { return self::regexp($input, $options['regex']); } case self::VALIDATE_CREDITCARD: { return self::creditCard($input, $options['type']); } } }  public static function creditCard($number, $type = null) { $types = array( 'visa' => '(4\d{12}(?:\d{3})?)', 'amex' => '(3[47]\d{13})', 'jcb' => '(35[2-8][89]\d\d\d{10})', 'maestro' => '((?:5020|5038|6304|6579|6761)\d{12}(?:\d\d)?)', 'solo' => '((?:6334|6767)\d{12}(?:\d\d)?\d?)', 'mastercard' => '(5[1-5]\d{14})', 'switch' => '(?:(?:(?:4903|4905|4911|4936|6333|6759)\d{12})|(?:(?:564182|633110)\d{10})(\d\d)?\d?)', ); if ($type && isset($types[$type])) { if (!preg_match('#^' . $types[$type] . '$#', $number)) { return false; } } else { foreach ($types as $t => $match) { if (preg_match('#^' . $match . '$#', $number)) { return self::luhn($number); } } return false; } return self::luhn($number); }  public static function luhn($number) { $number = (string) $number; $sumTable = array( array(0,1,2,3,4,5,6,7,8,9), array(0,2,4,6,8,1,3,5,7,9) ); $sum = 0; $flip = 0; for ($i = strlen($number) - 1; $i >= 0; $i--) { $sum += $sumTable[$flip++ & 0x1][$number[$i]]; } return $sum % 10 === 0; }  public static function number($value, $options = array()) { if (!is_numeric($value)) return false; if (isset($options['min_value']) && $value < $options['min_value']) return false; if (isset($options['max_value']) && $value > $options['max_value']) return false; return true; }  public static function string($value, $options = array()) { if (!is_string($value)) return false; if (!isset($options)) return true; $length = strlen($value); if (isset($options['min_length']) && $length < $options['min_length']) return false; if (isset($options['max_length']) && $length > $options['max_length']) return false; return true; }  public static function email($value) { return filter_var($value, FILTER_VALIDATE_EMAIL) ? true : false; }  public static function url($value) { return filter_var($value, FILTER_VALIDATE_URL) ? true : false; }  public static function ip($value) { return filter_var($value, FILTER_VALIDATE_IP) ? true : false; }  public static function regexp($value, $regexp) { return preg_match('#' . $regexp . '#', $value) ? true : false; }  public static function date($value, $options = array()) { $timestamp = strtotime($value); if (!is_numeric($timestamp)) { return false; } if (!checkdate(date('m', $timestamp), date('d', $timestamp), date('Y', $timestamp))) { return false; } if (isset($options['format'])) { $format = $options['format']; $format = str_replace(array('\\', '-','/',':', '[' , ']' , '(',')'), array('\\\\' ,'\-','\/','\:','\[','\]','\(','\)'), $format); $regex = str_replace( array('Y','m', 'M', 'd', 'j' , 'y', 'H', 'h' , 'a', 'A', 'g', 'G', 'i', 's'), array('[0-9]{4}','[0-9]{2}', '\w{3}', '[0-9]{2}', '[0-9]{1,2}', '[0-9]{2}', '[0-9]{2}', '[0-9]{2}', '\w{2}', '\w{2}', '[0-9]{1,2}', '[0-9]{1,2}', '[0-9]{2}', '[0-9]{2}'), $format ); if (!preg_match('#' . $regex . '#', $value)) { return false; } } if (isset($options['min_range']) && strtotime($options['min_range']) > $timestamp) { return false; } if (isset($options['max_range']) && strtotime($options['max_range']) < $timestamp) { return false; } return true; } const VALIDATE_NUMBER = 'number'; const VALIDATE_STRING = 'string'; const VALIDATE_EMAIL = 'email'; const VALIDATE_REGEXP = 'regex'; const VALIDATE_IP = 'ip'; const VALIDATE_DATE = 'date'; const VALIDATE_URL = 'url'; const VALIDATE_CREDITCARD='creditCard'; const CC_TYPE_VISA = 'visa'; const CC_TYPE_JBC = 'jbc'; const CC_TYPE_MAESTRO = 'maestro'; const CC_TYPE_SOLO = 'solo'; const CC_TYPE_MASTERCARD= 'mastercard'; const CC_TYPE_SWITCH = 'switch'; }
}
namespace alchemy\storage\cache {
    class APC implements IDriver { public static function isAvailable() { return extension_loaded('apc'); } public function get($key) { if (isset(self::$cache[$key])) return self::$cache[$key]; return self::$cache[$key] = apc_fetch($key); } public function set($key, $value, $ttl = null) { self::$cache[$key] = $value; return apc_store($key, $value, $ttl); } public function delete($key) { unset(self::$cache[$key]); return apc_delete($key); } public function exists($key) { return apc_exists($key); } public function flush() { return apc_clear_cache(self::APC_USER_CACHE_NAME); } private static $cache = array(); const APC_USER_CACHE_NAME = 'user'; }
    class Dummy implements IDriver {  public function __construct (&$cacheArray = null) { if ($cacheArray !== null) { $this->data = &$cacheArray; } else { $this->data = array(); } } public static function isAvailable() { return true; } public function get($key) { return isset($this->data[$key]) ? $this->data[$key] : null; } public function set($key, $value, $ttl = null) { $this->data[$key] = $value; } public function delete($key) { unset($this->data[$key]); } public function exists($key) { return isset($this->data[$key]); } public function flush() { $this->data = array(); } private $data; }
    class FileException extends \alchemy\storage\CacheException {}
    class File implements IDriver {  public function __construct ($filename) { if (!is_writable($filename)) { throw new FileException('Cache file `' . $filename . '` is not writeable!'); } $this->filename = $filename; $this->data = json_decode(file_get_contents($filename), true); } public static function isAvailable() { return true; } public function get($key) { return isset($this->data[$key]) ? ($this->data[$key]['ttl'] < time() ? $this->data[$key]['value'] : $this->delete($key)) : null; } public function set($key, $value, $ttl = null) { $this->data[$key] = array('ttl' => time() + $ttl, 'value' => $value); $this->write(); } public function delete($key) { unset($this->data[$key]); $this->write(); } public function exists($key) { return isset($this->data[$key]) ? $this->data[$key]['ttl'] > time() : false; } public function flush() { $this->data = array(); file_put_contents($this->filename, '{}'); } protected function write() { file_put_contents($this->filename, json_encode($this->data)); } private $filename; private $data = array(); }
    interface IDriver {  public function get($key);  public function set($key, $value, $ttl = null);  public function delete($key);  public function exists($key);  public function flush();  public static function isAvailable(); }
}
namespace alchemy\storage {
    use alchemy\app\Loader,alchemy\event\EventDispatcher,alchemy\util\AnnotationReflection,alchemy\storage\session\SessionNamespace,alchemy\storage\IStore;
    class CacheException extends \Exception {}
    class CacheDriverNotFoundException extends CacheException {}
    class Cache {  public static function addDriver(cache\IDriver $driver, $name = self::DEFAULT_DRIVER_NAME) { $driverName = $name ? $name : (method_exists($driver, 'getName') ? $driver->getName() : get_class($driver)); self::$driverList[$driverName] = $driver; self::$currentDriver = $driver; }  public static function useDriver($name) { if (!isset(self::$driverList[$name])) throw new CacheDriverNotFoundException(sprintf('You have to add driver first before using it, use %s'), __CLASS__ . '::addDriver()'); if (self::$currentDriver instanceof cache\IDriver) { self::$previousDriver = self::$currentDriver; } self::$currentDriver = self::$driverList[$name]; }  public static function restorePreviousDriver() { if (!(self::$previousDriver instanceof cache\IDriver)) return false; self::$currentDriver = self::$previousDriver; self::$previousDriver = null; return true; } public static function set($key, $value, $ttl = null, $driverName = null) { return self::getDriver($driverName)->set($key, $value, $ttl); } public static function get($key, $driverName = null) { return self::getDriver($driverName)->get($key); } public static function delete($key, $driverName = null) { return self::getDriver($driverName)->delete($key); } public static function flush($driverName = null) { return self::getDriver($driverName)->flush(); }  public static function getDriver($name = null) { if (!(self::$currentDriver instanceof cache\IDriver)) self::$currentDriver = new cache\Dummy(); if (!$name) return self::$currentDriver; if (!isset(self::$driverList[$name])) throw new CacheDriverNotFoundException(sprintf('You have to add driver first before using it, use %s'), __CLASS__ . '::addDriver()'); return self::$driverList[$name]; }  private static $driverList = array();  private static $currentDriver;  private static $previousDriver; const DEFAULT_DRIVER_NAME = 'DefaultCacheDriver'; }
    class CookieException extends \Exception {}
    class Cookie {  public function __set($name, $value) { self::set($name, $value); }  public static function set($name, $value, $expiration = null) { if ($expiration) { $expiration = time() + $expiration; } $_COOKIE[$name] = $value; if (!is_array($value)) { setcookie($name, $value, $expiration, '/'); return; } foreach ($value as $key => $v) { if (is_array($v)) { throw new CookieException('Invalid cookie value!'); } setcookie(sprintf('%s[%s]', $name, $key), $v, $expiration, '/'); } }  public function &__get($name) { $p = self::get($name); return $p; }  public static function &get($name) { $var = isset($_COOKIE[$name]) ? $_COOKIE[$name] : null; return $var; } }
    interface ISchema {  public function getPKProperty();  public function getPropertyList();  public function getStorageClass();  public function getProperty($name);  public function getCollectionName();  public function propertyExists($name);  public function getModelClass(); }
    interface IStorage { public function save(Model $model); public function delete(Model $model); public function get($modelName, $parameters); public function find(ISchema $schema, array $query = null, array $sort = null); public function findOne(ISchema $schema, array $query = null, array $sort = null); public function findAndModify(ISchema $schema, array $query = null, array $update, $returnData = false); public function findAndRemove(ISchema $schema, array $query = null, $returnData = false); }
    class ModelException extends \Exception {}
    abstract class Model extends EventDispatcher {  public function __construct($data = null) { $pkName = self::getSchema()->getPKProperty()->getName(); if ($data === null) { return; } elseif (is_string($data) || is_numeric($data)) { $this->{$pkName} = $data; } elseif (is_array($data)) {  if (isset($data[$pkName])) { $this->{$pkName} = $data[$pkName]; } $this->set($data); } else { throw new ModelException('Model::__construct() accepts string|int|array, ' . gettype($data) . ' passed'); } }  public static function create(array $data, Model $model = null) { if (!$model) { $class = get_called_class(); $model = new $class(); } foreach ($data as $property => $value) { $model->{$property} = $value; } return $model; } public static function onLoad() { }  public function set(array $data, $force = false) { foreach ($data as $property => $value) { $this->__set($property, $value); } }  public static function getSchema() { $class = get_called_class(); if (isset(self::$schemaList[$class])) { return self::$schemaList[$class]; } return self::$schemaList[$class] = SchemaBuilder::getSchema($class); }  public static function get($pk) { $modelName = get_called_class(); $storage = self::getStorage(); return $storage->get($modelName, $pk); }  public static function findOne(array $query = array(), array $sort = null) { $storage = self::getStorage(); return $storage->findOne(self::getSchema(), $query, $sort); }  public static function find(array $query = array(), array $sort = null) { $storage = self::getStorage(); return $storage->find(self::getSchema(), $query, $sort); } public static function findAndRemove($query, $returnData = false) { $storage = self::getStorage(); return $storage->findAndRemove(self::getSchema(), $query, $returnData); } public static function findAndModify(array $query = null, array $update, $returnData = false) { $storage = self::getStorage(); return $storage->findAndModify(self::getSchema(), $query, $update, $returnData); }  public static function query() { $storage = self::getStorage(); if (!method_exists($storage, 'query')) { throw new ModelException(get_class($connection) . ' does not support custom queries'); } return call_user_func_array(array($storage, 'query'), func_get_args()); }  public function __set($name, $value) { if (!self::getSchema()->propertyExists($name)) { throw new ModelException('Trying to set non existing property `' . $name . '` in model ' . get_called_class()); }  $this->setFields[$name] = $name; if (!isset($this->changes[$name])) { if ($this->{$name} != $value) { $this->changes[$name] = $value; $this->isChanged = true; } return; } if ($this->changes[$name] != $value) {  if ($value == $this->{$name}) { unset ($this->changes[$name]); $this->isChanged = false; return; } $this->changes[$name] = $value; $this->isChanged = true; } }  public function __get($name) { if (isset($this->changes[$name])) { return $this->changes[$name]; } return $this->{$name}; }  public function onSave() {}  public function onPersists() {}  public function onDelete() {}  public function onChange() {}  public function onGet() {} public function isNew() { return $this->getPK() == null ? true : false; } public function isChanged() { return $this->isChanged; }  public function getPK() { return $this->{self::getSchema()->getPKProperty()->getName()}; }  private function setPK($value) { $this->{self::getSchema()->getPKProperty()->getName()} = $value; }  public function save() { $storage = self::getStorage(); $this->onSave(); $storage->save($this); $this->applyChanges(); $this->onPersists(); return true; }  public function delete() { $storage = self::getStorage(); $this->onDelete(); $storage->delete($this);  $this->isChanged = true; $this->changes = $this->serialize(); $this->setPK(null); }  public function forceSave() { $this->forceSave = true; $this->isChanged = true; }  public function serialize() { $schema = self::getSchema(); $serialized = array(); foreach ($schema as $name => $property) { if (isset($this->changes[$name])) { $serialized[$name] = $this->changes[$name]; } else { $serialized[$name] = $this->{$name}; } } return $serialized; } public function getChanges() { if ($this->forceSave) { $changes = array(); foreach ($this->setFields as $field) { $changes[$field] = $this->__get($field); } return $changes; } return $this->changes; }  public function dispatch(\alchemy\event\Event $e) { \alchemy\event\EventHub::dispatch($e); parent::dispatch($e); }  protected static function getStorage() { $schema = self::getSchema(); return Storage::get($schema->getStorageClass()); } private function applyChanges() { foreach ($this->changes as $key => $value) { $this->{$key} = $value; } $this->changes = array(); $this->isChanged = false; } protected $forceSave = false; protected $changes = array(); protected $setFields = array(); protected $isChanged = false;  protected static $schemaList = array(); }
    class Property { public function __construct($name) { $this->name = $name; } public function getName() { return $this->name; } public function getType() { return $this->type; } public function setType($type) { $this->type = $type; } public function setRequired($required = true) { $this->required = $required; } public function isRequired() { return $this->required; } public function __toString() { return (string) $this->localName; } private $type; private $name; private $required = false; const TYPE_BOOL = 0; const TYPE_NUMBER = 1; const TYPE_STRING = 2; const TYPE_BLOB = 3; const TYPE_ENUM = 4; const TYPE_DATE = 5; const TYPE_ARRAY = 6; const TYPE_JSON = 7; }
    class SchemaBuilderException extends \Exception {}
    class SchemaBuilder {  public static function getSchema($className) { $schemaBuilder = new SchemaBuilder($className); $path = Loader::getPathForApplicationClass($className); $schemaPath = AL_APP_CACHE_DIR . '/' . sha1($path) . '.php'; if (is_readable($schemaPath) && self::$cache) { if (filemtime($schemaPath) >= filemtime($path)) {  require_once $schemaPath; return $schemaBuilder->getInstance(); } }  $schemaBuilder->build(); $schemaBuilder->save($schemaPath); require_once $schemaPath; return $schemaBuilder->getInstance(); } public static function disableCache() { self::$cache = false; } protected function __construct($className) { $this->className = $className; $this->schemaClassName = $className . self::SCHEMA_CLASS_POSTFIX; } protected function build() { $annotationReflection = new AnnotationReflection($this->className); $classAnnotations = $annotationReflection->getFromClass(); $propertyList = $annotationReflection->getDeclaredProperties(); $storageClass = Storage::getDefaultStorage();  if (!isset($classAnnotations[self::ANNOTATION_PK])) { throw new ModelException('Missing @' . self::ANNOTATION_PK . ' annotation in ' . $this->className . ' definition'); } $pk = $classAnnotations[self::ANNOTATION_PK]; if (is_array($pk)) { throw new ModelException('Alchemy models does not support compound keys yet!'); } if (isset($classAnnotations[self::ANNOTATION_STORAGE_CLASS])) { $storageClass = $classAnnotations[self::ANNOTATION_STORAGE_CLASS]; echo 'storageClass:' . $storageClass; } $className = explode('\\', $this->className); $namespace = implode('\\', array_slice($className,0, -1)); if ($namespace) { $namespace = 'namespace ' . $namespace . ';'; } $className = array_slice($className, -1);  if (isset($classAnnotations[self::ANNOTATION_COLLECTION])) { $collectionName = $classAnnotations[self::ANNOTATION_COLLECTION]; } else { $collectionName = $className[0]; } $className = $className[0] . self::SCHEMA_CLASS_POSTFIX; $constructBody = ''; $propertyAliases = array(); foreach ($propertyList as $propertyName) { $propertyAnnotation = $annotationReflection->getFromProperty($propertyName);  if (!isset($propertyAnnotation[self::ANNOTATION_PROPERTY])) { continue; } $annotation = $propertyAnnotation[self::ANNOTATION_PROPERTY];  $property = '        $this->propertyList[\'' . $propertyName . '\']'; $constructBody .= PHP_EOL . $property . ' = new \alchemy\storage\Property(\'' . $propertyName . '\');'; if (isset($annotation[self::PROPERTY_ATTRIBUTE_NAME])) { $propertyAliases[] = "\n\t" . '\'' . $propertyName . '\' => \'' . $annotation[self::PROPERTY_ATTRIBUTE_NAME] . '\''; } else { $propertyAliases[] = "\n\t" . '\'' . $propertyName . '\' => \'' . $propertyName . '\''; }  if (!isset($annotation[self::PROPERTY_ATTRIBUTE_TYPE])) { $type = self::$typeMap['string']; } else { $type = isset(self::$typeMap[$annotation[self::PROPERTY_ATTRIBUTE_TYPE]]) ? self::$typeMap[$annotation[self::PROPERTY_ATTRIBUTE_TYPE]] : self::$typeMap['default']; } $constructBody .= PHP_EOL . $property . '->setType(' . $type . ');';  if (isset($annotation[self::PROPERTY_ATTRIBUTE_REQUIRED])) { $constructBody .= PHP_EOL . $property . '->setRequired();'; } } $this->schemaData = sprintf(self::CLASS_TEMPLATE, $namespace,  $className,  $constructBody,  $pk,  $storageClass,  implode(',', $propertyAliases),  $collectionName,  $this->className  ); } protected function getInstance() { return new $this->schemaClassName; } protected function save($filename) { if ((is_file($filename) && !is_writable($filename)) || !is_writable(dirname($filename))) { throw new SchemaBuilderException('File ' . $filename . ' is not writeable'); } file_put_contents($filename,'<?php' . PHP_EOL . $this->schemaData); }  protected $className; protected $schemaClassName; protected $schemaData; protected static $cache = true; protected static $typeMap = array( 'string' => Property::TYPE_STRING, 'text' => Property::TYPE_STRING, 'int' => Property::TYPE_NUMBER, 'float' => Property::TYPE_NUMBER, 'number' => Property::TYPE_NUMBER, 'date' => Property::TYPE_DATE, 'json' => Property::TYPE_JSON, 'enum' => Property::TYPE_ENUM, 'bool' => Property::TYPE_BOOL, 'boolean' => Property::TYPE_BOOL, 'blob' => Property::TYPE_BLOB, 'default' => Property::TYPE_STRING ); const ANNOTATION_PK = 'pk'; const ANNOTATION_PROPERTY = 'param'; const ANNOTATION_STORAGE_CLASS = 'storage'; const ANNOTATION_COLLECTION = 'collection'; const PROPERTY_ATTRIBUTE_NAME = 'name'; const PROPERTY_ATTRIBUTE_REQUIRED = 'required'; const PROPERTY_ATTRIBUTE_TYPE = 'type'; const SCHEMA_CLASS_POSTFIX = 'Schema'; const CLASS_TEMPLATE = <<<CLASS
%s
/**
 * Class generated automatically by \alchemy\storage\SchemaBuilder
 * DO NOT CHANGE THIS MANUALLY
 */
final class %s implements \alchemy\storage\ISchema, \Iterator
{
    public function __construct()
    {
        %s
    }

    public function getPropertyList()
    {
        return \$this->propertyNameList;
    }

    public function __get(\$name)
    {
        return \$this->propertyList[\$name];
    }

    public function getProperty(\$name)
    {
        return \$this->propertyList[\$name];
    }

    public function getPKProperty()
    {
        return \$this->propertyList[\$this->pk];
    }

    public function getCollectionName()
    {
        return \$this->collectionName;
    }

    public function propertyExists(\$name)
    {
        return isset(\$this->propertyList[\$name]);
    }

    public function getStorageClass()
    {
        return \$this->storageClass;
    }
    public function rewind()
    {
        reset(\$this->propertyList);
    }
    public function current()
    {
        return current(\$this->propertyList);
    }
    public function key()
    {
        return key(\$this->propertyList);
    }
    public function next()
    {
        return next(\$this->propertyList);
    }
    public function valid()
    {
        \$key = key(\$this->propertyList);
        return \$key !== NULL && \$key !== FALSE;
    }

    public function getModelClass()
    {
        return \$this->modelClass;
    }

    protected \$pk = '%s';
    protected \$propertyList = array();
    protected \$storageClass = '%s';
    protected \$propertyNameList = array(%s);
    protected \$collectionName = '%s';
    protected \$modelClass = '%s';
}
CLASS;
}
    class Session {  public static function start() { if (self::isActive()) { return false; } if (self::$handler) { session_set_save_handler( array(self::$handler, 'open'), array(self::$handler, 'close'), array(self::$handler, 'read'), array(self::$handler, 'write'), array(self::$handler, 'destroy'), array(self::$handler, 'gc') ); } session_start(); self::$data = &$_SESSION; self::$sessionId = session_id(); return true; }  public static function isActive() { if (self::$sessionId) { return true; } return false; }  public static function getID() { return session_id(); }  public static function setID($id) { self::$sessionId = $id; session_id($id); }  public static function setHandler(\alchemy\storage\session\IHander $handler) { self::$handler = $handler; }  public static function destroy() { session_destroy(); }  public static function &get($name) { if (!isset(self::$data[$name])) { self::$data[$name] = new SessionNamespace(); } return self::$data[$name]; } private static $data = array();  private static $handler;  protected static $sessionId; }
    class StorageException extends \Exception {}
    class Storage {  public static function add(IStorage $storage) { $className = get_class($storage); self::$storages[$className] = $storage; self::$defaultStorage = $className; }  public static function get($id = null) { if (!$id) { $id = self::$defaultStorage; } if (!isset(self::$storages[$id])) { if (!class_exists($id)){ throw new StorageException('Storage `' . $id . '` class doed not exists'); } if (!class_implements($id, 'alchemy\storage\IStorage')) { throw new StorageException('Storage `' . $id . '` does not implement alchemy\storage\IStorage'); } self::$storages[$id] = new $id; } return self::$storages[$id]; } public static function setDefaultStorage($className) { if (!class_exists($className)) { throw new StorageException('Class ' . $className . ' does not exists'); } if (is_subclass_of($className, 'alchemy\storage\IStorage')) { self::$defaultStorage = $className; } else { throw new StorageException('Class ' . $className . ' must implement alchemy\storage\IStorage'); } } public static function getDefaultStorage() { return self::$defaultStorage; } protected static $defaultStorage = 'alchemy\storage\sql\SQLite'; protected static $storages = array(); }
}
namespace alchemy\storage\session {
    interface IHander {  public function open($savePath, $sessionName);  public function close();  public function read($sessionId); public function write($sessionId, $sessionData); public function destroy($sessionId); public function gc($maxLifetime); }
    class SessionNamespace implements \ArrayAccess, \Countable { public function offsetExists($offset) { return isset($this->data[$offset]); } public function count() { return count($this->data); } public function &offsetGet($offset) { if ($this->isExpired()) { $this->data = array(); $this->setExpiration($this->expirationTime); } return $this->data[$offset]; } public function __set($name, $value) { return $this->offsetSet($name, $value); } public function __get($name) { return $this->offsetGet($name); } public function __isset($name) { if ($this->isExpired()) { return false; } return $this->offsetExists($name); } public function __unset($name) { unset($this->data[$name]); } public function offsetSet($offset, $value) { if (is_null($offset)) { $this->data[] = $value; return; } $this->data[$offset] = $value; } public function offsetUnset($offset) { unset($this->data[$offset]); }  public function setExpiration($expire = 0) { $this->expirationTime = $expire; if ($expire === 0) { $this->expireAt = $expire; } else { $this->expireAt = time() + $this->expirationTime; } }  public function isExpired() { return $this->expireAt && time() >= $this->expireAt; } public function __sleep() { return array('data', 'expirationTime', 'expireAt'); } public function __wakeup() { if ($this->isExpired()) { $this->data = array(); } } protected $data = array(); protected $expireAt = 0; protected $expirationTime = 0; }
}
namespace alchemy\storage\sql {
    use alchemy\storage\Model,alchemy\storage\ISchema,alchemy\storage\IStorage,alchemy\storage\StorageException;
    class SQL extends \PDO implements IStorage {  public function query($sql, array $data = null, ISchema $schema = null) { $query = $this->prepare($sql); if (!($query instanceof \PDOStatement) || !$query->execute($data)) { $error = $this->errorInfo(); if ($error[1]) { throw new SQLException('[SQL ERROR] ' . $error[2] . ($schema ? ' in model class:' . $schema->getModelClass() : '')); } return; }  $queryType = substr($sql, 0, strpos($sql, ' ')); if (!in_array($queryType, self::$fetchableQueries)) { return true; }  $set = array(); if ($schema) { while($r = $query->fetchObject($schema->getModelClass())) { $set[$r->getPK()] = $r; $r->onGet(); } } else { $set = $query->fetchAll(\PDO::FETCH_ASSOC); } return $set; }  public function save(Model $model) { if (!$model->isChanged()) { return; } if ($model->isNew()) { $this->insert($model); } else { $this->update($model); } }  protected function update(Model $model) { $schema = $model::getSchema(); $pkField = $schema->getPKProperty()->getName(); $where = '`' . $pkField . '` = :pk'; $changes = $model->getChanges();  if (empty($changes)) { return false; } $fields = array(); foreach ($changes as $key => $value) { $fields[] = '`' . $key . '` = :' . $key; } $sql = sprintf(self::UPDATE_SQL, $schema->getCollectionName(), implode(',', $fields), $where);  $changes['pk'] = $model->getPK(); if (!$this->query($sql, $changes, $schema)) { $error = $this->errorInfo(); throw new SQLException('Cannot save model: ' . $error[2]); } }  protected function insert(Model $model) { $schema = $model::getSchema(); $fields = array(); $binds = array(); $changes = $model->getChanges(); foreach ($changes as $key => $value) { $fields[] = '`' . $key . '`'; $binds[] = ':' . $key; } $sql = sprintf(self::INSERT_SQL, $schema->getCollectionName(), implode(',', $fields), implode(',', $binds)); if(!$this->query($sql, $changes)) { $error = $this->errorInfo(); throw new SQLException('Cannot save model: ' . $error[2]); } $id = $this->lastInsertId(); if ($id) { $model->{$schema->getPKProperty()->getName()} = $id; } }  public function delete(Model $model) { $schema = $model::getSchema(); $pkField = $schema->getPKProperty(); $where = '`' . $pkField->getName() . '` = :pk'; $sql = sprintf(self::DELETE_SQL, $schema->getCollectionName(), $where); $this->query($sql, array('pk' => $model->getPK())); } public function get($model, $pkValue) { $schema = $model::getSchema(); $fieldList = '`' . implode('`,`', $schema->getPropertyList()) . '`'; $pkField = $schema->getPKProperty()->getName(); $where = '`' . $pkField. '` = :pk'; $sql = sprintf(self::GET_SQL, $fieldList, $schema->getCollectionName(), $where); $result = $this->query($sql, array('pk' => $pkValue), $schema); if (!$result) { return false; } $model = current($result); return $model; }  public function find(ISchema $schema, array $query = null, array $sort = null) { $sql = $this->generateFindSQL($schema, $query, $sort); return $this->query($sql, $query, $schema); } public function findOne(ISchema $schema, array $query = null, array $sort = null) { $sql = $this->generateFindSQL($schema, $query, $sort, 1); return current($this->query($sql, $query, $schema)); }  public function findAndModify(ISchema $schema, array $query = null, array $update, $returnData = false) { $where = $this->parseQuery($query); $updateFields = array(); $bind = array(); foreach ($update as $field => $value) { switch (substr($field, 0, 1)) { case '+': $field = substr($field, 1); $updateFields[] = '`' . $field . '` = `' . $field . '` + :' . $field; break; case '-': $field = substr($field, 1); $updateFields[] = '`' . $field . '` = `' . $field . '` - :' . $field; break; default: $updateFields[] = '`' . $field . '` = :' . $field; break; } if (!$schema->propertyExists($field)) { throw new SQLException($schema->getModelClass() . ' have not got propery `' . $field . '`'); } $bind[$field] = $value; } if ($returnData) { $fieldList = '`' . implode('`,`', $schema->getPropertyList()) . '`'; $sql = sprintf(self::FIND_SQL, $fieldList, $schema->getCollectionName(), $where); $returnData = $this->query($sql, $query, $schema); } $sql = sprintf(self::UPDATE_SQL, $schema->getCollectionName(), implode(',', $updateFields), $where); $bind = array_merge($query, $bind);  $q = $this->prepare($sql); if (!$q) { return false; } $updateQueryResult = $q->execute($bind); if ($updateQueryResult && $returnData !== false) { return $returnData; } return $updateQueryResult; }  public function findAndRemove(ISchema $schema, array $query = null, $returnData = false) { $where = $this->parseQuery($query); if ($returnData) { $fieldList = '`' . implode('`,`', $schema->getPropertyList()) . '`'; $sql = sprintf(self::FIND_SQL, $fieldList, $schema->getCollectionName(), $where); $returnData = $this->query($sql, $query, $schema); } $sql = sprintf(self::DELETE_SQL, $schema->getCollectionName(), $where); $q = $this->prepare($sql); if (!$q) { return false; } $removeQueryResult = $q->execute($query); if ($removeQueryResult && $returnData !== false) { return $returnData; } return $removeQueryResult; } private function generateFindSQL(ISchema $schema, array &$query = null, array $sort = null, $limit = null) { $fieldList = '`' . implode('`,`', $schema->getPropertyList()) . '`'; $where = $this->parseQuery($query); $sql = sprintf(self::FIND_SQL, $fieldList, $schema->getCollectionName(), $where); if ($sort) { $sql .= ' ORDER BY '; foreach ($sort as $field => $direction) { if (!isset(self::$sort[$direction])) { throw new SQLException(__CLASS__ . ' does not handle SORT TYPE:' . $direction); } $sql .= '`' . $field . '` ' . self::$sort[$direction] . ','; } $sql = substr($sql, 0, -1); } if ($limit) { $sql .= ' LIMIT ' . $limit; } return $sql; }  private function parseQuery(&$query) { if (!$query) { return ' 1'; } $bind = array(); foreach ($query as $key => $value) { $key = trim($key); $operator = '='; $sign = substr($key, -1); switch ($sign) { case '=': $sign = substr($key, -2); if ($sign == '>=' || $sign == '<=') { $operator = $sign; $key = trim(substr($key, 0, -2)); } else { $key = trim(substr($key, 0, -1)); } break; case '>': case '<': $operator = $sign; $key = trim(substr($key, 0, -1)); break; default: break; } if (is_array($value)) {  foreach ($value as &$v) { if (is_string($v)) { $v = $this->quote($v); } } $where[] = '`' . $key . '` IN (' . implode(',', $value) . ') '; continue; } $bind[$key] = $value; $where[] = '`' . $key . '` ' . $operator . ' :' . $key; } $query = $bind; $where = implode(' AND ', $where); return $where; } protected static $sort = array( -1 => 'DESC', 1 => 'ASC', 0 => '' ); const INSERT_SQL = 'INSERT INTO `%s`(%s) VALUES(%s)'; const UPDATE_SQL = 'UPDATE `%s` SET %s WHERE %s'; const DELETE_SQL = 'DELETE FROM `%s` WHERE %s'; const GET_SQL = 'SELECT %s FROM `%s` WHERE %s'; const FIND_SQL = 'SELECT %s FROM `%s` WHERE %s'; protected static $fetchableQueries = array('EXPLAIN', 'DESCRIBE', 'SELECT', 'SHOW'); }
    class MySQLException extends SQLException {}
    class MySQL extends SQL {  public function __construct($host, $user, $password, $db) { $dsn = 'mysql:dbname=' . $db . ';host=' . $host; parent::__construct($dsn, $user, $password, array( \PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES \'UTF8\'', \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION, \PDO::ATTR_PERSISTENT => true  )); } }
    class PgSQLException extends SQLException {}
    class PgSQL extends SQL {  public function __construct($host, $user, $password, $db) { $dsn = 'pgsql:dbname=' . $db . ';host=' . $host; parent::__construct($dsn, $user, $password, array( \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION, \PDO::ATTR_PERSISTENT => true  )); } }
    class SQLException extends StorageException {}
    class SQLiteException extends SQLException {}
    class SQLite extends SQL { public function __construct($fileName = self::USE_MEMORY) { $dsn = 'sqlite:' . $fileName; parent::__construct($dsn); } CONST USE_MEMORY = ':memory:'; }
}
namespace alchemy\template\mixture {
    use alchemy\template\MixtureException;
    class CompilerException extends \Exception {}
    class Compiler { public function __construct($fileName = '') { $this->fileName = $fileName; $this->setContext(self::MAIN_FUNCTION_NAME); } public function compile(Node $tree) { foreach ($tree->getChildren() as $node) { if ($node->getType() == Node::NODE_TEXT) {  $this->appendText(str_replace('<?', '&lt;?', $node->getValue())); continue; } $handler = $node->getHandler(); $handler = new $handler($node); $handler->handle($this); if ($node->hasChildren()) { $this->compile($node); } } } public static function getTemplateClassName($file) { return self::TEMPLATE_CLASS_SUFFIX . sha1($file); } public function getOutput($className) { ob_start();  echo '<?php use alchemy\template\Mixture; use \alchemy\template\mixture\Template;' . PHP_EOL; echo '//filename:' . $this->fileName . PHP_EOL; if ($this->dependencyFile) { echo 'Template::load(\'' . $this->dependencyFile . '\'); ' . PHP_EOL; } echo 'class ' . $className . ' extends ' . $this->extends . ' {' . PHP_EOL; foreach ($this->source as $methodName => $content) { if ($this->dependencyFile && $methodName == self::MAIN_FUNCTION_NAME) { continue; } elseif ($methodName == self::MAIN_FUNCTION_NAME) {  echo PHP_EOL . 'public function ' . $methodName . '() {' . PHP_EOL . 'ob_start();?>' . $content . '<?php $renderedTemplate = ob_get_contents(); ob_end_clean(); return $renderedTemplate;' . PHP_EOL . '}'; } else { echo 'public function ' . $methodName . '() {' . PHP_EOL . '?>' . $content . '<?php' . PHP_EOL . ' }'; } } echo PHP_EOL . '}' . PHP_EOL; $class = ob_get_contents(); ob_end_clean(); return $class; } public function appendText($text) { $this->source[$this->context] .= $text; } public function setText($text) { $this->source[$this->context] = $text; } public function setContext($name) { if ($this->context) { $this->lastContext[] = $this->context; } $this->context = $name; if (!isset($this->source[$name])) { $this->source[$name] = ''; } } public function removeContext($name) { unset($this->source[$name]); } public function gotoLastContext() { $context = array_pop($this->lastContext); if (!$context) { $context = self::MAIN_FUNCTION_NAME; } $this->context = $context; } public function setExtends($name) { $file = Template::getTemplateFileName($name); if (!is_readable($file)) { throw new CompilerException('Cannot extend unexistent template file ' . $name); } $this->extends = self::getTemplateClassName($file); $this->dependencyFile = $name; } protected $context = self::MAIN_FUNCTION_NAME; protected $lastContext = array(); protected $source = array(); protected $extends = self::TEMPLATE_EXTENDS; protected $dependencyFile; protected $fileName;  const TEMPLATE_EXTENDS = 'Template'; const MAIN_FUNCTION_NAME = 'render'; const TEMPLATE_CLASS_SUFFIX = 'MixtureTemplate'; }
    class ExpressionException extends \Exception {}
    interface IExpression { public static function isBlock(); public static function getCloseTag(); public static function getOpenTag(); public function handle(Compiler $compiler); }
    class Node { public function __construct($type = Node::NODE_TREE, $value = null) { $this->value = $value; $this->type = $type; } public function isRoot() { return $this->parent === null; } public function getParent() { return $this->parent; } public function setParent(Node $parent) { $this->parent = $parent; } public function addChild(Node $child) { $child->setParent($this); $this->children[] = $child; } public function addParameter($param) { $this->value .= ' ' . $param; $this->parameters[] = $param; } public function setValue($value) { $this->value = $value; } public function getValue() { return $this->value; } public function getChildren() { return $this->children; } public function hasChildren() { return !empty($this->children); } public function getTagname() { if (!isset($this->parameters[0])) { return null; } return $this->parameters[0]; } public function getType() { return $this->type; } public function getParameters() { return $this->parameters; } public function setHandler($className) { $this->handler = $className; } public function getHandler() { return $this->handler; } protected $value; protected $parameters = array(); protected $isRoot = false; protected $type = -1; protected $handler; protected $parent = null; protected $children = array(); const NODE_TREE = -1; const NODE_TEXT = 0; const NODE_VAR = 1; const NODE_TAG = 2; }
    class ParserException extends \Exception { public function __construct($message, Parser $p = null) { parent::__construct($message); if ($p) { $token = $p->getCurrentToken(); $this->line = $token['line'] + 1; $this->column = $token['column']; $this->file = $p->getTokenizer()->getFile(); $this->tokenizer = $p->getTokenizer(); } } public function __toString() { $fileData = explode("\n", $this->tokenizer->getText()); $context = ''; if (isset($fileData[$this->line - 2])) { $context .= $fileData[$this->line - 2] . PHP_EOL; } if (isset($fileData[$this->line - 1])) { $context .= $fileData[$this->line - 1] . PHP_EOL; } $context .= sprintf("%'-" . ($this->column + 1) . "s\n", '^'); $context .= $fileData[$this->line] . PHP_EOL; if (isset($fileData[$this->line + 1])) { $context .= $fileData[$this->line + 1] . PHP_EOL; } return 'MixtureException with message ' . $this->message . ' in ' . "\n" . $context; }  private $tokenizer; private $column; }
    class Parser { public function __construct(Tokenizer $tokenizer) { $this->tokenizer = $tokenizer; $this->tree = new Node();  $this->addExpression('\alchemy\template\mixture\expression\BlockExpression'); $this->addExpression('\alchemy\template\mixture\expression\I18nExpression'); $this->addExpression('\alchemy\template\mixture\expression\EachExpression'); $this->addExpression('\alchemy\template\mixture\expression\IfExpression'); $this->addExpression('\alchemy\template\mixture\expression\ImportExpression'); $this->addExpression('\alchemy\template\mixture\expression\UseExpression'); $this->addExpression('\alchemy\template\mixture\expression\ExtendExpression'); } public function addExpression($className) { if (!class_exists($className, true)) { throw new ParserException('Expression handler class ' . $className . ' does not exists'); } $open = $className::getOpenTag(); $close = $className::getCloseTag(); if ($open) { self::$openingExpressions[$open] = $className; } if ($close) { self::$closingExpressions[$close] = $className; } self::$blockExpressions[$open] = $className::isBlock(); self::$blockExpressions[$close] = $className::isBlock(); self::$openingTags[$close] = $open; self::$closingTags[$open] = $close; }  public function getTokenizer() { return $this->tokenizer; } public function getCurrentToken() { return $this->token; } public function parse() { $tokens = $this->tokenizer->scan(); $current = $this->tree; $next = null; $notExpecting = null; $expecting = null; foreach ($tokens as $token) { $this->token = &$token;  if ($expecting) { if (is_array($expecting) && !in_array($token['type'], $expecting)) { throw new ParserException('Unexpected ' . $token['value'] . ', expecting one of: ' . implode(',', $expecting), $this); } elseif (!is_array($expecting) && $expecting != $token['type']) { throw new ParserException('Unexpected ' . $token['value'] . ', expecting ' . $expecting, $this); } } if ($notExpecting) { if (is_array($notExpecting) && in_array($token['value'], $notExpecting)) { throw new ParserException('Unexpected ' . $token['value'], $this); } elseif (!is_array($notExpecting) && $notExpecting == $token['type']) { throw new ParserException('Unexpected ' . $token['value'], $this); } }  if ($next && $next != $token['type']) { continue; }  $next = null; $expecting = null; $notExpecting = null; switch ($token['type']) { case Tokenizer::T_TEXT: $current->addChild(new Node(Node::NODE_TEXT, $token['value'])); break; case Tokenizer::T_PARAM: $current->addParameter($token['value']); $expecting = array(Tokenizer::T_END_TAG, Tokenizer::T_PARAM, Tokenizer::T_END_VAR); break; case Tokenizer::T_TAG: $expecting = Tokenizer::T_PARAM; $tag = new Node(Node::NODE_TAG, $token['value']); $current->addChild($tag); $current = $tag; break; case Tokenizer::T_END_VAR: $current->setValue($current->getValue() . ' ' . $token['type']); $current = $current->getParent(); break; case Tokenizer::T_END_TAG: $current->setValue($current->getValue() . ' ' . $token['type']); $type = $current->getTagname(); if (!$this->isValidExpression($type)) {  $current->setHandler('\alchemy\template\mixture\expression\HelperExpression'); $current = $current->getParent(); break; } if (!self::$blockExpressions[$type] || $current->isRoot()) { $current->setHandler(self::$openingExpressions[$type]); $current = $current->getParent(); break; }  if (isset(self::$closingExpressions[$type])) {  $lastOpened = self::$openingTags[$type]; $current->setHandler(self::$closingExpressions[$type]); $current = $current->getParent()->getParent(); if (end($this->openTags) != $lastOpened) { $expected = self::$closingTags[end($this->openTags)]; throw new ParserException('Nesting conflict, expected "' . $expected . '", got "' . $type . '"', $this); } array_pop($this->openTags); } else { $current->setHandler(self::$openingExpressions[$type]); $this->openTags[] = $type; } break; case Tokenizer::T_VAR: $tag = new Node(Node::NODE_VAR, $token['value']); $tag->setHandler(self::VAR_HANDLER); $current->addChild($tag); $current = $tag; break; } }  if (!empty($this->openTags)) { throw new ParserException('Unexpected end of template file, expecting: ' . self::$closingTags[end($this->openTags)], $this); } return $this->tree; } private function isValidExpression($type) { return isset(self::$openingExpressions[$type]) || isset(self::$closingExpressions[$type]); } protected $tree; protected static $openingExpressions = array(); protected static $closingExpressions = array(); protected static $blockExpressions = array(); protected static $openingTags = array(); protected static $closingTags = array(); protected $token;  protected $tokenizer; private $openTags = array(); const BLOCK_END_EXPR = 'end'; const VAR_HANDLER = '\alchemy\template\mixture\expression\VarExpression'; }
    class TemplateException extends MixtureException {}
    class Template {  public static function factory($name, &$data) { self::load($name); $templateFileName = self::getTemplateFileName($name); $templateClassName = Compiler::getTemplateClassName($templateFileName); return new $templateClassName($data); }  public static function getTemplateFileName($name) { return self::$templateDir . DIRECTORY_SEPARATOR . $name; }  public static function load($name) { $templateFileName = self::getTemplateFileName($name); if (!is_readable($templateFileName)) { throw new TemplateException('Template file:' . $templateFileName . ' is not readable'); } $templateClassName = Compiler::getTemplateClassName($templateFileName);  if (class_exists($templateClassName)) { return true; } $templateCacheFileName = DIRECTORY_SEPARATOR . $templateClassName . '.php';  if (self::$cacheDir) { $templateCacheFileName = self::$cacheDir . $templateCacheFileName; if (is_readable($templateCacheFileName) && filemtime($templateCacheFileName) >= filemtime($templateFileName)) { require_once $templateCacheFileName; return true; } } else { $templateCacheFileName = sys_get_temp_dir() . $templateCacheFileName; }  try { $parser = new Parser(new Tokenizer($templateFileName)); } catch (\Exception $e) { throw new TemplateException('Unexpected error occured while loading your template file'); } $compiler = new Compiler($templateFileName); $compiler->compile($parser->parse()); $template = $compiler->getOutput($templateClassName);  file_put_contents($templateCacheFileName, $template); require_once $templateCacheFileName; return true; } public static function setOption($name, $value) { self::$options[$name] = $value; } public static function getOption($name) { if (!isset(self::$options[$name])) { return null; } return self::$options[$name]; }  public static function setCacheDir($dir) { self::$cacheDir = $dir; }  public static function setTemplateDir($dir) { self::$templateDir = $dir; } protected function __construct(&$data = array()) { if ($data instanceof VarStack) { $this->stack = $data; } else { $this->stack = new VarStack($data); } }  public function import($name) { echo self::factory($name, $this->stack)->render(); }  public function render() { return ''; }  protected static $cacheDir;  protected static $options = array( self::OPTION_DATE_FORMAT => 'Y.m.d', self::OPTION_DATETIME_FORMAT => 'Y.m.d H:i:s', self::OPTION_TIME_FORMAT => 'H:i:s', self::OPTION_NUMBER_FORMAT => array(0, '.' , ','), self::OPTION_CURRENCY_SUFFIX => 'USD' );  protected static $templateDir;  protected $stack; const OPTION_DATE_FORMAT = 1; const OPTION_DATETIME_FORMAT = 2; const OPTION_TIME_FORMAT = 3; const OPTION_NUMBER_FORMAT = 4; const OPTION_CURRENCY_SUFFIX = 5; }
    class TokenizerException extends \Exception {}
    class Tokenizer { public function __construct($file) { if (!is_readable($file)) { throw new TokenizerException('File is not readable ' . $file); } $this->file = $file; $this->text = file_get_contents($file); } public function scan() { $length = strlen($this->text); $buffer = ''; $stringDelimiter = ''; $inVar = false; $prevC = null; for (; $this->index < $length; $this->index++) { $this->column++; if ($this->index > 0) { $prevC = $this->text[$this->index - 1]; } $c = $this->text[$this->index]; if ($this->index + 1 < $length) { $token = $c . $this->text[$this->index + 1]; } if ($c == PHP_EOL) { $this->line++; $this->column = 0; } switch ($this->state) { case self::S_TEXT: if (isset(self::$oTokens[$token])) { $this->addToken(self::T_TEXT, $buffer); $buffer = ''; } switch ($token) { case self::T_TAG: $this->state = self::S_TAG; $this->addToken(self::T_TAG, $token); $this->index++; continue 3; case self::T_VAR: $inVar = true; $this->state = self::S_TAG; $this->addToken(self::T_VAR, $token); $this->index++; continue 3; case self::T_IGNORE: $this->state = self::S_IGNORE; $this->addToken(self::T_IGNORE, $token); $this->index++; continue 3; } break; case self::S_TAG: if (ctype_space($c)) { continue 2; } elseif ($inVar && $c == '}') { $this->addToken(self::T_END_VAR, $c); $inVar = false; $buffer = ''; $this->state = self::S_TEXT; continue 2; } elseif (!$inVar && $token == self::T_END_TAG) { $this->addToken(self::T_END_TAG, $token); $buffer = ''; $this->state = self::S_TEXT; $this->index++; continue 2; } $this->state = self::S_PARAM; case self::S_PARAM: if ($c == '"' || $c == '\'') { $this->state = self::S_STRING; $stringDelimiter = $c; $buffer = ''; continue 2; } if (ctype_space($c)) { $this->addToken(self::T_PARAM, $buffer); $buffer = ''; $this->state = self::S_TAG; continue 2; } if ($inVar && $c == self::T_END_VAR) {  if ($buffer) { $this->addToken(self::T_PARAM, $buffer); $buffer = ''; } $this->addToken(self::T_END_VAR, $c); $this->state = self::S_TEXT; $inVar = false; continue 2; } if (!$inVar && $token == self::T_END_TAG) { $this->index++;  if ($buffer) { $this->addToken(self::T_PARAM, $buffer); $buffer = ''; } $this->addToken(self::T_END_TAG, $token); $this->state = self::S_TEXT; continue 2; } break; case self::S_STRING: if ($c == $stringDelimiter && $prevC != '\\') { $this->addToken(self::T_PARAM, $buffer); $buffer = ''; $this->state = self::S_TAG; continue 2; } break; case self::S_IGNORE: if ($token == self::T_END_IGNORE) { $this->addToken(self::T_TEXT, $buffer); $buffer = ''; $this->addToken(self::T_END_IGNORE, $token); $this->state = self::S_TEXT; $this->index++; continue 2; } break; } $buffer .= $c; } if ($buffer) { $this->addToken(self::T_TEXT, $buffer); } return $this->tokens; } public function getTokens() { return $this->tokens; } public function getText() { return $this->text; } public function getFile() { return $this->file; } protected function addToken($type, $value) { $this->tokens[] = array( 'type' => $type, 'value' => $value, 'column'=> $this->column, 'line' => $this->line, 'index' => $this->index ); } protected $state = self::S_TEXT; protected $line = 0; protected $index = 0; protected $column = 0; protected $tokens = array();  protected static $oTokens = array( self::T_TAG => true, self::T_VAR => true, self::T_IGNORE => true ); protected $file; protected $text;  const T_TAG = '{%'; const T_END_TAG = '%}'; const T_VAR = '${'; const T_END_VAR = '}'; const T_IGNORE = '{!'; const T_END_IGNORE = '!}';  const T_TEXT = 'text'; const T_PARAM = 'param';  const S_TEXT = 0; const S_TAG = 1; const S_PARAM = 2; const S_STRING = 3; const S_IGNORE = 4; }
    class VarStack { public function __construct($data = array()) { $this->data = $data; $this->current = $this->data; } public function get($varname) { if (!$varname || !$this->current) { return null; } if ($varname == '.') { return $this->current; } $return = $this->current; foreach(explode('.', $varname) as $path) {  if ($return === null) { return null; }  if (is_string($return)) { if ($path == 'length' || $path == 'size') { $return = strlen($return); continue; } if (is_numeric($path)) { $return = $return{$path}; continue; } return null; }  if (is_array($return)) { if (isset($return[$path])) { $return = $return[$path]; continue; } if ($path == 'length' || $path == 'size') { $return = count($return); continue; } return null; }  if (is_object($return)) { if (method_exists($return, $path) && is_callable(array($return, $path))) { $return = $return->$path(); continue; } if (property_exists($return, $path)) { $return = $return->$path; continue; } if ($return instanceof ArrayAccess && $return->offsetExists($path)) { $return = $return->offsetGet($path); continue; } if (($path === 'length' || $path === 'size') && $return instanceof Countable) { $return = count($return); continue; } if (method_exists($return, '__isset') && $return->__isset($path)) { $return = $return->$path; continue; } elseif (method_exists($return, '__get')) { $return = $return->$path; continue; } return null; } } return $return; } public function in($var) { $this->stack[] = $var; $this->current = $this->get($var); } public function out() { array_pop($this->stack); if (empty($this->stack)) { $this->current = $this->data; return; } $this->current = $this->get(end($this->stack)); } public function set($name, $value) { $this->current[$name] = $value; } public function reset() { $this->current = $this->data; if (empty ($this->stack)) { return; } $in = end($this->stack); $this->current = $this->get($in); } public function remove($name) { } protected $current; protected $data; protected $stack; }
}
namespace alchemy\template\mixture\expression {
    use alchemy\template\mixture\ExpressionException,alchemy\template\mixture\IExpression,alchemy\template\mixture\Node,alchemy\template\mixture\Compiler,alchemy\template\mixture\Template;
    class BlockExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return true; } public static function getOpenTag() { return 'block'; } public static function getCloseTag() { return 'endblock'; } public function handle(Compiler $compiler) { if ($this->node->getTagname() == self::getCloseTag()) { $compiler->gotoLastContext(); return; } $parameters = $this->node->getParameters(); if (!isset($parameters[1])) { throw new ExpressionException('Missing block name'); } $func = 'userBlock' . self::sanitizeName($parameters[1]); $compiler->appendText('<?php $this->' . $func . '(); ?>'); $compiler->setContext($func); } public static function sanitizeName($name) { return str_replace(array('-','.','/','+','*','&','^','#','@'), '_', $name); }  protected $node; }
    class EachExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return true; } public static function getOpenTag() { return 'each'; } public static function getCloseTag() { return 'endeach'; } public function handle(Compiler $compiler) { if ($this->node->getTagname() == self::getCloseTag()) { array_pop(self::$iteratedItems); $compiler->appendText('<?php endforeach; endif;?>'); return; } $parameters = $this->node->getParameters(); if ($parameters[2] != 'in') { throw new CompilerException('Used unknown expression ' . $parameters[2] . ' in ' . $parameters[0] . ' tag'); } if ($parameters[1]{0} == '$') { $parameters[1] = substr($parameters[1], 1); } self::$iteratedItems[] = $parameters[1]; $index = self::getVariable('index'); $key = self::getVariable('key'); $value = self::getVariable('value'); $odd = self::getVariable('odd'); $even = self::getVariable('even'); $last = self::getVariable('last'); $first = self::getVariable('first'); $length = self::getVariable('length');  if ($parameters[3]{0} == '$') { $var = VarExpression::getVariableReference($parameters[3]); $compiler->appendText('<?php if(is_array(' . $var. ')): ' . $index . ' = 0; ' . $length . ' = count(' . $var . '); foreach(' . $var . ' as ' . $key . ' => ' . $value . '):'); $compiler->appendText('$this->stack->set(\'' . $parameters[1] . '\', ' . $value . ');'); $compiler->appendText( $first . ' = ' . $index. ' == 0 ? true : false;' . $last . ' = ' . $length . ' - 1 == ' . $index . ' ? true : false;' . $index . '++;' . $odd . ' = ' . $index . '%2 ? false : true;' . $even . ' = !' . $odd . '; ' . '?>'); return; } if (!preg_match('#^(\d+)\.\.(\d+)$#', $parameters[3], $matches)) { throw new CompilerException('Used unknown expression ' . $parameters[3] . ' in ' . $parameters[0] . ' tag'); } $range = self::getVariable('range'); $compiler->appendText('<?php if(true): ' . $index .' = 0; ' . $range .' = range(' . $matches[1] . ',' . $matches[2] . ');' . $length . ' = count(' . $range . '); foreach(' . $range . ' as ' . $key . ' => ' . $value . '):'); $compiler->appendText('$this->stack->set(\'' . $parameters[1] . '\', ' . $value . ');'); $compiler->appendText( $first . ' = ' . $index. ' == 0 ? true : false;' . $last . ' = ' . $length . ' - 1 == ' . $index . ' ? true : false;' . $index . '++;' . $odd . ' = ' . $index . '%2 ? false : true;' . $even . ' = !' . $odd . '; ' . '?>'); } public static function getVariable($type, $iteratedItem = null) { return '$_each' . $type . '_' . ($iteratedItem ? $iteratedItem : end(self::$iteratedItems)); } public static function isIterationAvailable($name) { return in_array($name, self::$iteratedItems); }  protected $node; protected static $rangeNumber = 0;  protected static $iteratedItems = array(); }
    class ExtendExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return false; } public static function getOpenTag() { return 'extends'; } public static function getCloseTag() { } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); $compiler->setExtends($parameters[1]); }  protected $node; }
    class HelperExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return false; } public static function getOpenTag() { return '*'; } public static function getCloseTag() { } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); $helper = array_shift($parameters); $params = array(); if ($parameters) { foreach ($parameters as $p) { if (preg_match('#^\$[a-z0-9\.-_]+$#', $p)) { $params[] = VarExpression::getVariableReference($p); } else { $p = '\'' . addcslashes($p, '\'') . '\''; preg_match_all('#[^\\\](\$[a-z0-9\._]+)#i', $p, $m); if ($m[0]) { for ($i = 0; $i < count($m[0]); $i++) { $p = str_replace($m[1][$i], ('\' . ' . VarExpression::getVariableReference($m[1][$i]) . ' . \'') , $p); } $params[] = $p; } else { $params[] = $p; } } } $compiler->appendText('<?php Mixture::callHelper(\'' . $helper . '\', array(' . implode(',', $params) . ', $this));?>'); } else { $compiler->appendText('<?php Mixture::callHelper(\'' . $helper . '\', array($this));?>'); } }  protected $node; }
    class I18nExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return false; } public static function getOpenTag() { return '_'; } public static function getCloseTag() { } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); $compiler->appendText('<?php echo "' . addcslashes($parameters[1], '"') . '"?>'); }  protected $node; }
    class IfExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return true; } public static function getOpenTag() { return 'if'; } public static function getCloseTag() { return 'endif'; }  public function handle(Compiler $compiler) { if ($this->node->getTagname() == self::getCloseTag()) { $compiler->appendText('<?php endif;?>'); return; } $parameters = $this->node->getParameters(); $length = count($parameters); if ($length < 2) { throw new CompilerException('If expression requires at least one parameter, none given'); } if ($length == 2) { $compiler->appendText('<?php if(' . VarExpression::getVariableReference($parameters[1]) . '):?>'); return; } if ($parameters[2] == 'not') { $not = '!'; } else { $not = null; } $iteratedItem = substr($parameters[1],1); if ($length == 4) { switch (true) { case $parameters[3] == 'number': $compiler->appendText('<?php if(' . $not . 'is_numeric(' . VarExpression::getVariableReference($parameters[1]) . ')):?>'); break; case $parameters[3] == 'odd' && EachExpression::isIterationAvailable($iteratedItem): case $parameters[3] == 'even' && EachExpression::isIterationAvailable($iteratedItem): case $parameters[3] == 'first' && EachExpression::isIterationAvailable($iteratedItem): case $parameters[3] == 'last' && EachExpression::isIterationAvailable($iteratedItem): $compiler->appendText('<?php if(' . $not . EachExpression::getVariable($parameters[3], $iteratedItem) . '):?>'); break; case is_numeric($parameters[3]): $compiler->appendText('<?php if(' . VarExpression::getVariableReference($parameters[1]) . ' ' . ($not ? $not : '=' ) . '= ' . $parameters[3] . '):?>'); break; default: $compiler->appendText('<?php if(' . VarExpression::getVariableReference($parameters[1]) . ' ' . ($not ? $not : '=' ) . '= \'' . addslashes($parameters[3]) . '\'):?>'); break; } return; } throw new CompilerException('An error occured in if expression'); }  protected $node; }
    class ImportExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return false; } public static function getOpenTag() { return 'import'; } public static function getCloseTag() { } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); $compiler->appendText('<?php $this->import(\'' . $parameters[1] . '\')?>'); }  protected $node; }
    class UseExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return true; } public static function getOpenTag() { return 'use'; } public static function getCloseTag() { return 'enduse'; } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); if ($this->node->getTagname() == self::getCloseTag()) { $compiler->appendText('<?php endif; $this->stack->out();?>'); return; } if ($parameters[1]{0} != '$') { throw new CompilerException('Cannot use keyword as variable in ' . $parameters[0] . ' expression'); } $compiler->appendText('<?php $this->stack->in(\'' . substr($parameters[1], 1) . '\'); if($this->get(\'.\')):?>'); }  protected $node; }
    class VarExpression implements IExpression { public function __construct(Node $node) { $this->node = $node; } public static function isBlock() { return false; } public static function getOpenTag() { } public static function getCloseTag() { } public function handle(Compiler $compiler) { $parameters = $this->node->getParameters(); $var = self::getVariableReference($parameters[0]); if (in_array('strip', $parameters)) { $var = 'strip(' . $var . ')'; } if (in_array('trim', $parameters)) { $var = 'trim(' . $var . ')'; }  if (in_array('date', $parameters)) { $dateFormat = Template::getOption(Template::OPTION_DATE_FORMAT); $var = 'is_numeric(' . $var . ') ? date(\'' . $dateFormat . '\', ' . $var . ') : date(\'' . $dateFormat . '\', strtotime(' . $var . '))'; } elseif (in_array('datetime', $parameters)) { $dateFormat = Template::getOption(Template::OPTION_DATETIME_FORMAT); $var = 'is_numeric(' . $var . ') ? date(\'' . $dateFormat . '\', ' . $var . ') : date(\'' . $dateFormat . '\', strtotime(' . $var . '))'; } else { $isCurrenty = in_array('currency', $parameters); if (in_array('number', $parameters) || $isCurrenty) { $numberFormat = Template::getOption(Template::OPTION_NUMBER_FORMAT); $var = 'number_format(' . $var . ', ' . $numberFormat[0] . ', \'' . $numberFormat[1] . '\', \'' . $numberFormat[2] . '\')'; if ($isCurrenty) { $var = $var . '.\' ' . Template::getOption(Template::OPTION_CURRENCY_SUFFIX) . '\''; } } elseif (!in_array('unescape', $parameters)) {  $var = 'htmlentities(' . $var . ', ENT_QUOTES, \'UTF-8\')'; } } $compiler->appendText('<?php echo ' . $var . '?>'); } public static function getVariableReference($name) {  if ($name == '.' || $name == 'this' || $name == '$.') { return '$this->stack->get(\'.\')'; }  if ($name{0} == '@') { $name = substr($name, 1);  if (!isset(self::$loopVars[$name])) { return 'null'; } return EachExpression::getVariable($name); }  if ($name{0} == '$') { return '$this->stack->get(\''. substr($name, 1) . '\')'; }  return '$this->stack->get(\''. $name . '\')'; }  protected $node; protected static $loopVars = array('odd' => true, 'even' => true, 'index' => true, 'value' => true, 'key' => true, 'last' => true, 'first' => true); }
}
namespace alchemy\template {
    use alchemy\template\mixture\Tokenizer,alchemy\template\mixture\Parser,alchemy\template\mixture\Compiler,alchemy\template\mixture\Template;
    class MixtureException extends \Exception {}
    class Mixture {  public static function setDateFormat($format = 'Y.m.d') { Template::setOption(Template::OPTION_DATE_FORMAT, $format); }  public static function setDatetimeFormat($format = 'Y.m.d H:i:s') { Template::setOption(Template::OPTION_DATETIME_FORMAT, $format); }  public static function setNumberFormat($decimals = 0, $decimalsSeparator = '.', $thousandsSeparator = ',') { Template::setOption(Template::OPTION_NUMBER_FORMAT, array($decimals, $decimalsSeparator, $thousandsSeparator)); } public static function setCurrencySuffix($suffix = 'USD') { Template::setOption(Template::OPTION_CURRENCY_SUFFIX, $suffix); } public function __construct($dir = null) { if (!$dir) { $this->dir = AL_APP_DIR . DIRECTORY_SEPARATOR . 'template'; } else { $this->dir = realpath($dir); } $this->cache = sys_get_temp_dir(); } public static function addHelper($name, $callable) { self::$helpers[$name] = $callable; } public static function helperExists($name) { return isset(self::$helpers[$name]); } public static function callHelper($name, $args) { if (!self::helperExists($name)) { throw new MixtureException('Call to undefined helper function ' . $name); } return call_user_func_array(self::$helpers[$name], $args); } public function setCacheDir($dir) { $dir = realpath($dir); if (!is_dir($dir)) { throw new MixtureException('Cache dir ' . $dir . ' does not exists'); } $this->cache = $dir; } public function disableCache() { $this->cache = false; } public function render($name, &$data = array()) { if ($this->cache) { Template::setCacheDir($this->cache); } else { Template::setCacheDir(false); } Template::setTemplateDir($this->dir); $tpl = Template::factory($name, $data); return $tpl->render(); } protected $dir; protected $cache; protected static $helpers; }
}
namespace alchemy\util\annotation {
    final class Parser { final public static function parse($string) { $string = trim(preg_replace('/\r?\n *|^\/\*\*/', ' ', $string)); preg_match_all('#' . self::MATCH_ANNOTATION . '#is', $string, $annotations); if (!count($annotations[1])) { return null; } foreach ($annotations[2] as &$value) { $value = self::parseValue($value); } foreach ($annotations[1] as &$name) { $name = strtolower($name); } $result = array_combine($annotations[1], $annotations[2]); return $result; } final public static function parseValue($string) { if (empty($string)) { return true; }  if ($string[0] != '(') { return trim($string); }  return self::parseAnnotationValue($string); } final protected static function parseAnnotationValue($string) { $len = strlen($string) - 1; $result = array(); $var = null; $buffer = ''; $quota = null; $state = self::ST_DEFAULT; for ($i = 1; $i < $len; $i++) { $c = $string[$i]; switch ($state) { case self::ST_DEFAULT: if (!$buffer && $c== ' ') { continue 2; } switch ($c) { case ' ': continue 3; case '=': $var = $buffer; $buffer = ''; $state = self::ST_VALUE; continue 3; case ',': if (isset(self::$keywords[$buffer])) { $buffer = self::$keywords[$buffer]; } if (empty($var)) { $result[] = $buffer; } else { $result[$var] = $buffer; } $var = null; $buffer = ''; $quota = null; continue 3; case '"': case '\'': $quota = $c; $state = self::ST_STRING; continue 3; } break; case self::ST_VALUE: if ($c == ',') { if (isset(self::$keywords[$buffer])) { $buffer = self::$keywords[$buffer]; } if (empty($var)) { $result[] = $buffer; } else { $result[$var] = $buffer; } $var = null; $buffer = ''; $quota = null; $state = self::ST_DEFAULT; continue 2; } elseif (($c == '"' || $c == '\'') && !$buffer) { $quota = $c; $state = self::ST_STRING; continue 2; } break; case self::ST_STRING: if ($quota == $c) { $state = self::ST_DEFAULT; continue 2; } break; } $buffer .= $c; } if ($buffer) { if (isset(self::$keywords[$buffer])) { $buffer = self::$keywords[$buffer]; }   if (empty($result) && !$var) { $result = $buffer; } else { if ($var) { $result[$var] = $buffer; } else { $result[] = $buffer; } } } return $result; } private static $keywords = array( 'false' => false, 'FALSE' => false, 'true' => true, 'TRUE' => true ); const ST_DEFAULT = 0; const ST_VALUE = 1; const ST_STRING = 2; const MATCH_ANNOTATION = '@([a-z0-9_]+)(.*?)\s+\*'; }
}
namespace alchemy\util {
    use alchemy\util\annotation\Parser,alchemy\http\Headers;
    final class AnnotationReflection {  public function __construct($class) { if (is_object($class)) { $class = get_class($class); } $this->reflectionClass = new \ReflectionClass($class);  $this->classAnnotation = Parser::parse($this->reflectionClass->getDocComment());  foreach ($this->reflectionClass->getMethods() as $m) { if ($m->getDeclaringClass()->getName() != $class) { continue; } $this->declaredMethods[] = $m->getName(); $this->methodsAnnotation[$m->getName()] = Parser::parse($m->getDocComment()); }  foreach ($this->reflectionClass->getProperties() as $p) { if ($p->getDeclaringClass()->getName() != $class) { continue; } $this->declaredProperties[] = $p->getName(); $this->propertiesAnnotation[$p->getName()] = Parser::parse($p->getDocComment()); } }  public function getDeclaredMethods() { return $this->declaredMethods; }  public function getDeclaredProperties() { return $this->declaredProperties; }  public function getFromClass() { return $this->classAnnotation; }  public function getFromMethod($name) { if (isset($this->methodsAnnotation[$name])) { return $this->methodsAnnotation[$name]; } }  public function getFromProperty($name) { if (isset($this->propertiesAnnotation[$name])) { return $this->propertiesAnnotation[$name]; } } protected $reflectionClass; protected $classAnnotation = array(); protected $methodsAnnotation = array(); protected $propertiesAnnotation = array(); private $declaredMethods = array(); private $declaredProperties = array(); }
    class CLI { static public function clearScreen() { print chr(27) . "[H" . chr(27) . "[2J"; } static public function centeredOutput($string, $width = null, $foreground = null, $background = null) { if (!$width) { $width = 80; } $repair = 0; $length = strlen($string); $padding = floor(($width - $length) / 2); if ($padding * 2 + $length < $width) { $repair = 1; } $string = sprintf('%' . $padding . 's%' . $length . 's%' . ($padding + $repair) . 's', '', $string, ''); self::output($string, $foreground, $background); } static public function multiLineCenteredOutput($string, $width = null, $foreground = null, $background = null) { if (!$width) { $width = 80; } $string = explode("\n", $string); foreach ($string as $s) { $repair = 0; $length = strlen($s); $padding = floor(($width - $length) / 2); if ($padding * 2 + $length < $width) { $repair = 1; } $s = sprintf('%' . $padding . 's%' . $length . 's%' . ($padding + $repair) . 's', '', $s, ''); self::output($s, $foreground, $background); self::eol(); } } static public function eol() { self::output(PHP_EOL); } static public function getCLIParameters() { $argv = $_SERVER['argv']; print_r($argv); array_shift($argv); $out = array(); foreach ($argv as $arg) { if (substr($arg, 0, 2) == '--') { $eqPos = strpos($arg, '='); if ($eqPos === false) { $key = substr($arg, 2); $out[$key] = isset($out[$key]) ? $out[$key] : true; } else { $key = substr($arg, 2, $eqPos - 2); $out[$key] = substr($arg, $eqPos + 1); } } else if (substr($arg, 0, 1) == '-') { if (substr($arg, 2, 1) == '=') { $key = substr($arg, 1, 1); $out[$key] = substr($arg, 3); } else { $chars = str_split(substr($arg, 1)); foreach ($chars as $char) { $key = $char; $out[$key] = isset($out[$key]) ? $out[$key] : true; } } } else { $out[] = $arg; } } return $out; } static public function output($string, $foreground = null, $background = null) { $output = ''; if ($foreground && isset(self::$foregroundList[$foreground])) { $output .= "\033[" . self::$foregroundList[$foreground] . 'm'; } if ($background && isset(self::$backgroundList[$background])) { $output .= "\033[" . self::$backgroundList[$background] . 'm'; } $output .= $string . "\033[0m"; print $output; } protected static $backgroundList = array( 'black' => '40', 'red' => '41', 'green' => '42', 'yellow' => '43', 'blue' => '44', 'magenta' => '45', 'cyan' => '46', 'gray' => '47' ); protected static $foregroundList = array( 'black' => '0;30', 'dark_gray' => '1;30', 'blue' => '0;34', 'light_blue' => '1;34', 'green' => '0;32', 'light_green' => '1;32', 'cyan' => '0;36', 'light_cyan' => '1;36', 'red' => '0;31', 'light_red' => '1;31', 'purple' => '0;35', 'light_purple' => '1;35', 'brown' => '0;33', 'yellow' => '1;33', 'light_gray' => '0;37', 'white' => '1;37' ); }
    class I18nException extends \Exception {}
    class I18n { public function __construct() { if (!function_exists('gettext')) { throw new I18nException('Gettext extension is required to use this feature'); } }  public function addDomain($domain = 'messages', $path = 'locale') { if (defined('AL_APP_DIR')) { $path = AL_APP_DIR . '/' . $path; } if (!is_dir($path)) { throw new I18nException('Could not add domain: `' . $path . '` does not exists'); } bindtextdomain($domain, $path); if ($this->encoding) { bind_textdomain_codeset($domain, $this->encoding); } $this->registeredDomains[$domain] = $path; }  public function useDomain($domain = 'messages') { if (!isset($this->registeredDomains[$domain])) { throw new I18nException('Before using `' . $domain . '` domain use ' . __CLASS__ . '::addDomain($domain, $path) method'); } $this->currentDomain = $domain; return textdomain($domain); }  public function setDefaultLanguage($lang = 'en') { $this->defaultLanguage = $lang; }  public function getDefaultLanguage() { return $this->defaultLanguage; }  public function setLanguage($lang) { $lang = $this->getLangForAlias($lang); if ($this->isLanguageAvailable($lang)) { $this->setPHPEnvironment($lang); } else { $this->setPHPEnvironment($this->defaultLanguage); } return textdomain($this->currentDomain); }  public function acceptFromCookies($name = 'userLanguage') { $userLanguage = isset($_COOKIE[$name]) ? $_COOKIE[$name] : false; if (!$userLanguage) { $this->acceptFromHTTP(); return false; } $this->setLanguage($userLanguage); return true; }  public function acceptFromHTTP() { if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) { $langList = Headers::parseAccept($_SERVER['HTTP_ACCEPT_LANGUAGE']); foreach ($langList as $lang) { $lang = explode('-', $lang['type']); if (isset($lang[1])) { $lang = strtolower($lang[0]) . '_' . strtoupper($lang[1]); } else { $lang = strtolower($lang[0]); } $lang = $this->getLangForAlias($lang); if (!$this->isLanguageAvailable($lang)) { continue; } $this->setPHPEnvironment($lang); return textdomain($this->currentDomain); } } if (!$this->isLanguageAvailable($this->defaultLanguage)) { throw new I18nException('Default language is not avaible'); } $this->setPHPEnvironment($this->defaultLanguage); return textdomain($this->currentDomain); }  public function addAlias($alias, $lang) { if (isset($this->aliases[$lang])) { $this->aliases[$alias] = &$this->aliases[$lang]; } else { $this->aliases[$alias] = $lang; } } public function getLangForAlias($alias) { return isset($this->aliases[$alias]) ? $this->aliases[$alias] : $alias; }  public function isLanguageAvailable($lang) { if (empty($this->registeredDomains)) { $this->addDomain('messages', 'locale'); } $path = $this->registeredDomains[$this->currentDomain]; return is_dir($path . '/' . $lang); } protected function setPHPEnvironment($lang) { putenv("LANG=$lang"); putenv("LANGUAGE=$lang"); setlocale(LC_ALL, $lang . '.' . $this->encoding); setlocale(LC_NUMERIC, 'C'); $this->currentLanguage = $lang; } public static $countryCodes = array( 'AD' => 'Andorra', 'AL' => 'Shqipria', 'AM' => 'Hayastan', 'AT' => 'sterreich', 'AZ' => 'Azerbaycan', 'BA' => 'Bosna i Hercegovina', 'BE' => 'Belgique, Belgi', 'BG' => 'Bulgaria', 'BY' => 'Belarus', 'CH' => 'Schweiz, Suisse, Svizzera, Svizra', 'CS' => 'Srbija i Crna Gora', 'CZ' => 'esk republika', 'CY' => 'Kpros', 'DE' => 'Deutschland', 'DK' => 'Danmark', 'EE' => 'Eesti', 'ES' => 'Espaa', 'FI' => 'Suomi, Finland', 'FR' => 'France', 'GB' => 'United Kingdom', 'US' => 'United States', 'GE' => 'Sakartvelo', 'GR' => 'Ellda', 'HR' => 'Hrvatska', 'HU' => 'Magyarorszg', 'IE' => 'Ireland, ire', 'IL' => 'Yisra\'el', 'IS' => 'sland', 'IT' => 'It lia', 'LT' => 'Lietuva', 'LU' => 'Luxembourg, Luxemburg, Ltzebuerg', 'LV' => 'Latvija', 'MA' => 'Al Maghreb', 'MC' => 'Monaco', 'MD' => 'Moldova', 'ME' => 'Crna Gora', 'MK' => 'Makedonija', 'MT' => 'Malta', 'NL' => 'Nederland, Nerderln', 'NO' => 'Norge', 'PL' => 'Polska', 'PT' => 'Portugal', 'RO' => 'Romnia', 'RS' => 'Srbija', 'RU' => 'Rossija', 'SE' => 'Sverige', 'SI' => 'Slovenija', 'SK' => 'Slovensko', 'SM' => 'San Marino', 'TR' => 'Trkiye', 'UA' => 'Ukrana', 'YU' => 'Jugoslavija' ); protected $defaultLanguage = 'en'; protected $currentLanguage; protected $currentDomain = 'messages'; protected $registeredDomains = array(); protected $encoding = 'UTF-8'; protected $aliases = array(); }
    class String {  public static function stripAccent($string) { if (!preg_match('/[\x80-\xff]/', $string)) return $string; if (mb_check_encoding($string, 'UTF-8')) { $chars = array(  chr(195) . chr(128) => 'A', chr(195) . chr(129) => 'A', chr(195) . chr(130) => 'A', chr(195) . chr(131) => 'A', chr(195) . chr(132) => 'A', chr(195) . chr(133) => 'A', chr(195) . chr(134) => 'AE', chr(195) . chr(135) => 'C', chr(195) . chr(136) => 'E', chr(195) . chr(137) => 'E', chr(195) . chr(138) => 'E', chr(195) . chr(139) => 'E', chr(195) . chr(140) => 'I', chr(195) . chr(141) => 'I', chr(195) . chr(142) => 'I', chr(195) . chr(143) => 'I', chr(195) . chr(144) => 'D', chr(195) . chr(145) => 'N', chr(195) . chr(146) => 'O', chr(195) . chr(147) => 'O', chr(195) . chr(148) => 'O', chr(195) . chr(149) => 'O', chr(195) . chr(150) => 'O', chr(195) . chr(153) => 'U', chr(195) . chr(154) => 'U', chr(195) . chr(155) => 'U', chr(195) . chr(156) => 'U', chr(195) . chr(157) => 'Y', chr(195) . chr(158) => 'TH', chr(195) . chr(159) => 's', chr(195) . chr(160) => 'a', chr(195) . chr(161) => 'a', chr(195) . chr(162) => 'a', chr(195) . chr(163) => 'a', chr(195) . chr(164) => 'a', chr(195) . chr(165) => 'a', chr(195) . chr(166) => 'ae', chr(195) . chr(167) => 'c', chr(195) . chr(168) => 'e', chr(195) . chr(169) => 'e', chr(195) . chr(170) => 'e', chr(195) . chr(171) => 'e', chr(195) . chr(172) => 'i', chr(195) . chr(173) => 'i', chr(195) . chr(174) => 'i', chr(195) . chr(175) => 'i', chr(195) . chr(176) => 'd', chr(195) . chr(177) => 'n', chr(195) . chr(178) => 'o', chr(195) . chr(179) => 'o', chr(195) . chr(180) => 'o', chr(195) . chr(181) => 'o', chr(195) . chr(182) => 'o', chr(195) . chr(184) => 'o', chr(195) . chr(185) => 'u', chr(195) . chr(186) => 'u', chr(195) . chr(187) => 'u', chr(195) . chr(188) => 'u', chr(195) . chr(189) => 'y', chr(195) . chr(190) => 'th', chr(195) . chr(191) => 'y',  chr(196) . chr(128) => 'A', chr(196) . chr(129) => 'a', chr(196) . chr(130) => 'A', chr(196) . chr(131) => 'a', chr(196) . chr(132) => 'A', chr(196) . chr(133) => 'a', chr(196) . chr(134) => 'C', chr(196) . chr(135) => 'c', chr(196) . chr(136) => 'C', chr(196) . chr(137) => 'c', chr(196) . chr(138) => 'C', chr(196) . chr(139) => 'c', chr(196) . chr(140) => 'C', chr(196) . chr(141) => 'c', chr(196) . chr(142) => 'D', chr(196) . chr(143) => 'd', chr(196) . chr(144) => 'D', chr(196) . chr(145) => 'd', chr(196) . chr(146) => 'E', chr(196) . chr(147) => 'e', chr(196) . chr(148) => 'E', chr(196) . chr(149) => 'e', chr(196) . chr(150) => 'E', chr(196) . chr(151) => 'e', chr(196) . chr(152) => 'E', chr(196) . chr(153) => 'e', chr(196) . chr(154) => 'E', chr(196) . chr(155) => 'e', chr(196) . chr(156) => 'G', chr(196) . chr(157) => 'g', chr(196) . chr(158) => 'G', chr(196) . chr(159) => 'g', chr(196) . chr(160) => 'G', chr(196) . chr(161) => 'g', chr(196) . chr(162) => 'G', chr(196) . chr(163) => 'g', chr(196) . chr(164) => 'H', chr(196) . chr(165) => 'h', chr(196) . chr(166) => 'H', chr(196) . chr(167) => 'h', chr(196) . chr(168) => 'I', chr(196) . chr(169) => 'i', chr(196) . chr(170) => 'I', chr(196) . chr(171) => 'i', chr(196) . chr(172) => 'I', chr(196) . chr(173) => 'i', chr(196) . chr(174) => 'I', chr(196) . chr(175) => 'i', chr(196) . chr(176) => 'I', chr(196) . chr(177) => 'i', chr(196) . chr(178) => 'IJ', chr(196) . chr(179) => 'ij', chr(196) . chr(180) => 'J', chr(196) . chr(181) => 'j', chr(196) . chr(182) => 'K', chr(196) . chr(183) => 'k', chr(196) . chr(184) => 'k', chr(196) . chr(185) => 'L', chr(196) . chr(186) => 'l', chr(196) . chr(187) => 'L', chr(196) . chr(188) => 'l', chr(196) . chr(189) => 'L', chr(196) . chr(190) => 'l', chr(196) . chr(191) => 'L', chr(197) . chr(128) => 'l', chr(197) . chr(129) => 'L', chr(197) . chr(130) => 'l', chr(197) . chr(131) => 'N', chr(197) . chr(132) => 'n', chr(197) . chr(133) => 'N', chr(197) . chr(134) => 'n', chr(197) . chr(135) => 'N', chr(197) . chr(136) => 'n', chr(197) . chr(137) => 'N', chr(197) . chr(138) => 'n', chr(197) . chr(139) => 'N', chr(197) . chr(140) => 'O', chr(197) . chr(141) => 'o', chr(197) . chr(142) => 'O', chr(197) . chr(143) => 'o', chr(197) . chr(144) => 'O', chr(197) . chr(145) => 'o', chr(197) . chr(146) => 'OE', chr(197) . chr(147) => 'oe', chr(197) . chr(148) => 'R', chr(197) . chr(149) => 'r', chr(197) . chr(150) => 'R', chr(197) . chr(151) => 'r', chr(197) . chr(152) => 'R', chr(197) . chr(153) => 'r', chr(197) . chr(154) => 'S', chr(197) . chr(155) => 's', chr(197) . chr(156) => 'S', chr(197) . chr(157) => 's', chr(197) . chr(158) => 'S', chr(197) . chr(159) => 's', chr(197) . chr(160) => 'S', chr(197) . chr(161) => 's', chr(197) . chr(162) => 'T', chr(197) . chr(163) => 't', chr(197) . chr(164) => 'T', chr(197) . chr(165) => 't', chr(197) . chr(166) => 'T', chr(197) . chr(167) => 't', chr(197) . chr(168) => 'U', chr(197) . chr(169) => 'u', chr(197) . chr(170) => 'U', chr(197) . chr(171) => 'u', chr(197) . chr(172) => 'U', chr(197) . chr(173) => 'u', chr(197) . chr(174) => 'U', chr(197) . chr(175) => 'u', chr(197) . chr(176) => 'U', chr(197) . chr(177) => 'u', chr(197) . chr(178) => 'U', chr(197) . chr(179) => 'u', chr(197) . chr(180) => 'W', chr(197) . chr(181) => 'w', chr(197) . chr(182) => 'Y', chr(197) . chr(183) => 'y', chr(197) . chr(184) => 'Y', chr(197) . chr(185) => 'Z', chr(197) . chr(186) => 'z', chr(197) . chr(187) => 'Z', chr(197) . chr(188) => 'z', chr(197) . chr(189) => 'Z', chr(197) . chr(190) => 'z', chr(197) . chr(191) => 's',  chr(200) . chr(152) => 'S', chr(200) . chr(153) => 's', chr(200) . chr(154) => 'T', chr(200) . chr(155) => 't',  chr(226) . chr(130) . chr(172) => 'E',  chr(194) . chr(163) => ''); $string = strtr($string, $chars); } else {  $chars['in'] = chr(128) . chr(131) . chr(138) . chr(142) . chr(154) . chr(158) . chr(159) . chr(162) . chr(165) . chr(181) . chr(192) . chr(193) . chr(194) . chr(195) . chr(196) . chr(197) . chr(199) . chr(200) . chr(201) . chr(202) . chr(203) . chr(204) . chr(205) . chr(206) . chr(207) . chr(209) . chr(210) . chr(211) . chr(212) . chr(213) . chr(214) . chr(216) . chr(217) . chr(218) . chr(219) . chr(220) . chr(221) . chr(224) . chr(225) . chr(226) . chr(227) . chr(228) . chr(229) . chr(231) . chr(232) . chr(233) . chr(234) . chr(235) . chr(236) . chr(237) . chr(238) . chr(239) . chr(241) . chr(242) . chr(243) . chr(244) . chr(245) . chr(246) . chr(248) . chr(249) . chr(250) . chr(251) . chr(252) . chr(253) . chr(255); $chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy"; $string = strtr($string, $chars['in'], $chars['out']); $double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254)); $double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th'); $string = str_replace($double_chars['in'], $double_chars['out'], $string); } return $string; } public static function urlize($string, $replacement = '-') { $str = strtolower(trim(self::stripAccent($string))); $pass = false; $return = ''; $length = strlen($str); for ($i = 0; $i < $length; $i++) { $c = $str[$i]; if (ctype_alnum($c)) { $return .= $c; $pass = false; } elseif ($pass) { continue; } else { $return .= $replacement; $pass = true; } } return $return; } public static function sanitizeRegex($string) { return str_replace( array('.','?','*','(',')','[',']','#'), array('\.','\?','\*','\(','\)','\[','\]','\#'), $string ); } }
}
namespace alchemy\vendor {
    class DropboxException extends \Exception {}
    class Dropbox { public function __construct($key = 'pwgvypkmmjat3jz', $secret = 'w2b7en2xwlfrmoo', $namespace = 'dropbox') { $this->key = $key; $this->secret = $secret; $this->requestTokenSecret = &$_SESSION[$namespace . '_oauth_request_secret']; $this->requestToken = &$_SESSION[$namespace . '_oauth_request_token']; $this->oauthToken = &$_SESSION[$namespace . '_oauth_token']; $this->oauthTokenSecret = &$_SESSION[$namespace . '_oauth_secret']; } public function forget() { $this->requestToken = null; $this->requestTokenSecret = null; $this->oauthToken = null; $this->oauthTokenSecret = null; } public function getAuthorizationURL($callback = 'http://lotos/lotos/projects/edit/1') { if (!$this->requestToken || !$this->requestTokenSecret) { $token = $this->doRequest('/oauth/request_token'); $this->requestTokenSecret = $token['oauth_token_secret']; $this->requestToken = $token['oauth_token']; } return self::DB_GATEWAY . '/authorize?oauth_token=' . $this->requestToken . '&oauth_callback=' . $callback; } public function authorize($oauthToken, $oauthTokenSecret) { $this->oauthToken = $oauthToken; $this->oauthTokenSecret = $oauthTokenSecret; } public function isAuthorized() { if ($this->oauthTokenSecret && $this->oauthToken) { return true; } return false; } public function getAccountInfo() { $data = $this->doRequest('/account/info'); if ($this->reponseCode != 200) { $this->forget(); $error = json_decode($this->response, true); throw new DropboxException($error['error'], $this->reponseCode); } return $data; } public function getAccessToken($requestToken = null) { if ($this->isAuthorized() && !$requestToken) { return true; } if (!$requestToken) { if (isset($_GET['oauth_token'])) { $requestToken = $_GET['oauth_token']; } else { throw new DropboxException('Please authorize user first by Dropbox->getAuthorizationURL'); } } $this->oauthToken = $requestToken; $response = $this->doRequest('/oauth/access_token'); $this->oauthTokenSecret = $response['oauth_token_secret']; $this->oauthToken = $response['oauth_token']; } protected function doRequest($url, $data = array()) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, self::API_GATEWAY . $url); $headers = $this->getHeaders(); print_r($headers); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 60); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, array()); $httpResponse = curl_exec($ch); $info = curl_getinfo($ch); $this->reponseCode = $info['http_code']; $this->response = $httpResponse; curl_close($ch); parse_str($httpResponse, $response); return $response; } private function getHeaders() { return array( 'Authorization: OAuth oauth_version="1.0", oauth_signature_method="PLAINTEXT",' . ' oauth_consumer_key="' . $this->key . '"' . ( $this->oauthToken ? ', oauth_token="' . $this->oauthToken . '"' : ( $this->requestToken ? ', oauth_token="' . $this->requestToken . '"' : '' ) ) . ', oauth_signature="' . $this->secret . '&' . ( $this->oauthToken ? $this->oauthTokenSecret : ( $this->requestTokenSecret ? $this->requestTokenSecret : '' ) ) . '"', 'Content-Type: multipart/form-data;' ); } const API_GATEWAY = 'https://api.dropbox.com/1'; const DB_GATEWAY = 'https://www.dropbox.com/1/oauth'; protected $key = ''; protected $secret = ''; protected $requestTokenSecret; protected $requestToken; protected $oauthToken; protected $oauthTokenSecret; private $reponseCode; private $response; }
    class PayPalException extends \Exception {}
    class PayPal {  public function __construct($username, $password, $signature) { $this->user = $username; $this->password = $password; $this->signature = $signature; }  public static function setSandbox($sandbox = true) { self::$sandbox = $sandbox; }  public function setPaymentCurrency($currency = 'USD') { $this->currency = $currency; }  public function getPaymentCurrency() { return $this->currency; }  public function addPaymentRequest(paypal\PaymentRequest $request) { $request->_setPayPal($this); $this->paymentRequests[] = $request; }  public function getToken() { return $this->token; }  public function generateExpressCheckoutToken($returnURL, $cancelURL) { if (empty($this->paymentRequests)) throw new PayPalException('You must call ' . __CLASS__ . "::addPaymentRequest before generating express checkout token"); $checkoutData = array( 'RETURNURL' => $returnURL, 'CANCELURL' => $cancelURL ); foreach ($this->paymentRequests as $p) { $checkoutData = array_merge($checkoutData, $p->serialize()); } $response = $this->doRequest('SetExpressCheckout', $checkoutData); if ($response['ACK'] != 'Success') { throw new PayPalException($response['L_SHORTMESSAGE0'] . PHP_EOL . $response['L_LONGMESSAGE0'], $response['L_ERRORCODE0']); } return $this->token = $response['TOKEN']; }  public function getExpressCheckoutURL($returnURL, $cancelURL, $commit = true) { $token = $this->getToken(); if (!$token) $token = $this->generateExpressCheckoutToken($returnURL, $cancelURL); $url = self::$sandbox ? self::SANDBOX_URL : self::PRODUCTION_URL; return $url . ($commit ? '&useraction=commit' : '') . '&token=' . $token; }  public function getExpressCheckoutDetails($token) { $data = array( 'TOKEN' => $token ); $response = $this->doRequest('GetExpressCheckoutDetails', $data); if ($response['ACK'] != 'Success') { throw new PayPalException('Invalid token or paypal timeout'); } return $response; } public function doExpressCheckoutPayment($token) { $checkoutDetails = $this->getExpressCheckoutDetails($token); if (!array_key_exists('PAYERID', $checkoutDetails)) return false; $paymentData = array( 'TOKEN' => $token, 'PAYERID' => $checkoutDetails['PAYERID'], );  foreach ($checkoutDetails as $key => $value) { if (preg_match('#PAYMENTREQUEST_\d+_AMT#is', $key)) $paymentData[$key] = $value; else if (preg_match('#PAYMENTREQUEST_\d+_CURRENCYCODE#is', $key)) $paymentData[$key] = $value; } $paymentData['PAYMENTREQUEST_0_PAYMENTACTION'] = 'Sale'; $response = $this->doRequest('DoExpressCheckoutPayment', $paymentData); if ($response['ACK'] == 'Success') return $response; return false; } protected function doRequest($method, $data) { $data = array_merge($data, array( 'METHOD' => $method, 'VERSION' => '86.0', 'PWD' => $this->password, 'USER' => $this->user, 'SIGNATURE' => $this->signature, )); $post = ''; foreach ($data as $n => $d) { $post .= '&' . $n . '=' . urlencode($d); } $gateway = self::$sandbox ? self::SANDBOX_API_GATEWAY : self::PRODUCTION_API_GATEWAY; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $gateway); curl_setopt($ch, CURLOPT_VERBOSE, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 30); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); $httpResponse = curl_exec($ch); parse_str($httpResponse, $response); return $response; } private $user; private $password; private $signature; private $currency = 'USD'; private $totalCost = 0.00; private static $sandbox = false; private $paymentRequests = array(); private $token; const SANDBOX_URL = 'https://www.sandbox.paypal.com/webscr?cmd=_express-checkout'; const PRODUCTION_URL = 'https://www.paypal.com/webscr&cmd=_express-checkout'; const PRODUCTION_API_GATEWAY = 'https://api-3t.paypal.com/nvp'; const SANDBOX_API_GATEWAY = 'https://api-3t.sandbox.paypal.com/nvp'; }
}
namespace alchemy\vendor\paypal {
    class DropboxException extends \Exception {}
    class Dropbox { public function __construct($key = 'pwgvypkmmjat3jz', $secret = 'w2b7en2xwlfrmoo', $namespace = 'dropbox') { $this->key = $key; $this->secret = $secret; $this->requestTokenSecret = &$_SESSION[$namespace . '_oauth_request_secret']; $this->requestToken = &$_SESSION[$namespace . '_oauth_request_token']; $this->oauthToken = &$_SESSION[$namespace . '_oauth_token']; $this->oauthTokenSecret = &$_SESSION[$namespace . '_oauth_secret']; } public function forget() { $this->requestToken = null; $this->requestTokenSecret = null; $this->oauthToken = null; $this->oauthTokenSecret = null; } public function getAuthorizationURL($callback = 'http://lotos/lotos/projects/edit/1') { if (!$this->requestToken || !$this->requestTokenSecret) { $token = $this->doRequest('/oauth/request_token'); $this->requestTokenSecret = $token['oauth_token_secret']; $this->requestToken = $token['oauth_token']; } return self::DB_GATEWAY . '/authorize?oauth_token=' . $this->requestToken . '&oauth_callback=' . $callback; } public function authorize($oauthToken, $oauthTokenSecret) { $this->oauthToken = $oauthToken; $this->oauthTokenSecret = $oauthTokenSecret; } public function isAuthorized() { if ($this->oauthTokenSecret && $this->oauthToken) { return true; } return false; } public function getAccountInfo() { $data = $this->doRequest('/account/info'); if ($this->reponseCode != 200) { $this->forget(); $error = json_decode($this->response, true); throw new DropboxException($error['error'], $this->reponseCode); } return $data; } public function getAccessToken($requestToken = null) { if ($this->isAuthorized() && !$requestToken) { return true; } if (!$requestToken) { if (isset($_GET['oauth_token'])) { $requestToken = $_GET['oauth_token']; } else { throw new DropboxException('Please authorize user first by Dropbox->getAuthorizationURL'); } } $this->oauthToken = $requestToken; $response = $this->doRequest('/oauth/access_token'); $this->oauthTokenSecret = $response['oauth_token_secret']; $this->oauthToken = $response['oauth_token']; } protected function doRequest($url, $data = array()) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, self::API_GATEWAY . $url); $headers = $this->getHeaders(); print_r($headers); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 60); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, array()); $httpResponse = curl_exec($ch); $info = curl_getinfo($ch); $this->reponseCode = $info['http_code']; $this->response = $httpResponse; curl_close($ch); parse_str($httpResponse, $response); return $response; } private function getHeaders() { return array( 'Authorization: OAuth oauth_version="1.0", oauth_signature_method="PLAINTEXT",' . ' oauth_consumer_key="' . $this->key . '"' . ( $this->oauthToken ? ', oauth_token="' . $this->oauthToken . '"' : ( $this->requestToken ? ', oauth_token="' . $this->requestToken . '"' : '' ) ) . ', oauth_signature="' . $this->secret . '&' . ( $this->oauthToken ? $this->oauthTokenSecret : ( $this->requestTokenSecret ? $this->requestTokenSecret : '' ) ) . '"', 'Content-Type: multipart/form-data;' ); } const API_GATEWAY = 'https://api.dropbox.com/1'; const DB_GATEWAY = 'https://www.dropbox.com/1/oauth'; protected $key = ''; protected $secret = ''; protected $requestTokenSecret; protected $requestToken; protected $oauthToken; protected $oauthTokenSecret; private $reponseCode; private $response; }
    class PayPalException extends \Exception {}
    class PayPal {  public function __construct($username, $password, $signature) { $this->user = $username; $this->password = $password; $this->signature = $signature; }  public static function setSandbox($sandbox = true) { self::$sandbox = $sandbox; }  public function setPaymentCurrency($currency = 'USD') { $this->currency = $currency; }  public function getPaymentCurrency() { return $this->currency; }  public function addPaymentRequest(paypal\PaymentRequest $request) { $request->_setPayPal($this); $this->paymentRequests[] = $request; }  public function getToken() { return $this->token; }  public function generateExpressCheckoutToken($returnURL, $cancelURL) { if (empty($this->paymentRequests)) throw new PayPalException('You must call ' . __CLASS__ . "::addPaymentRequest before generating express checkout token"); $checkoutData = array( 'RETURNURL' => $returnURL, 'CANCELURL' => $cancelURL ); foreach ($this->paymentRequests as $p) { $checkoutData = array_merge($checkoutData, $p->serialize()); } $response = $this->doRequest('SetExpressCheckout', $checkoutData); if ($response['ACK'] != 'Success') { throw new PayPalException($response['L_SHORTMESSAGE0'] . PHP_EOL . $response['L_LONGMESSAGE0'], $response['L_ERRORCODE0']); } return $this->token = $response['TOKEN']; }  public function getExpressCheckoutURL($returnURL, $cancelURL, $commit = true) { $token = $this->getToken(); if (!$token) $token = $this->generateExpressCheckoutToken($returnURL, $cancelURL); $url = self::$sandbox ? self::SANDBOX_URL : self::PRODUCTION_URL; return $url . ($commit ? '&useraction=commit' : '') . '&token=' . $token; }  public function getExpressCheckoutDetails($token) { $data = array( 'TOKEN' => $token ); $response = $this->doRequest('GetExpressCheckoutDetails', $data); if ($response['ACK'] != 'Success') { throw new PayPalException('Invalid token or paypal timeout'); } return $response; } public function doExpressCheckoutPayment($token) { $checkoutDetails = $this->getExpressCheckoutDetails($token); if (!array_key_exists('PAYERID', $checkoutDetails)) return false; $paymentData = array( 'TOKEN' => $token, 'PAYERID' => $checkoutDetails['PAYERID'], );  foreach ($checkoutDetails as $key => $value) { if (preg_match('#PAYMENTREQUEST_\d+_AMT#is', $key)) $paymentData[$key] = $value; else if (preg_match('#PAYMENTREQUEST_\d+_CURRENCYCODE#is', $key)) $paymentData[$key] = $value; } $paymentData['PAYMENTREQUEST_0_PAYMENTACTION'] = 'Sale'; $response = $this->doRequest('DoExpressCheckoutPayment', $paymentData); if ($response['ACK'] == 'Success') return $response; return false; } protected function doRequest($method, $data) { $data = array_merge($data, array( 'METHOD' => $method, 'VERSION' => '86.0', 'PWD' => $this->password, 'USER' => $this->user, 'SIGNATURE' => $this->signature, )); $post = ''; foreach ($data as $n => $d) { $post .= '&' . $n . '=' . urlencode($d); } $gateway = self::$sandbox ? self::SANDBOX_API_GATEWAY : self::PRODUCTION_API_GATEWAY; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $gateway); curl_setopt($ch, CURLOPT_VERBOSE, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 30); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); $httpResponse = curl_exec($ch); parse_str($httpResponse, $response); return $response; } private $user; private $password; private $signature; private $currency = 'USD'; private $totalCost = 0.00; private static $sandbox = false; private $paymentRequests = array(); private $token; const SANDBOX_URL = 'https://www.sandbox.paypal.com/webscr?cmd=_express-checkout'; const PRODUCTION_URL = 'https://www.paypal.com/webscr&cmd=_express-checkout'; const PRODUCTION_API_GATEWAY = 'https://api-3t.paypal.com/nvp'; const SANDBOX_API_GATEWAY = 'https://api-3t.sandbox.paypal.com/nvp'; }
}